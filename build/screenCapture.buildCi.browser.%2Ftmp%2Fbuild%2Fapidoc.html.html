<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/baconjs/bacon.js">baconjs (v0.7.93)</a>
</h1>
<h4>A small functional reactive programming lib for JavaScript.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs">module baconjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus">
            function <span class="apidocSignatureSpan">baconjs.</span>Bus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe">
            function <span class="apidocSignatureSpan">baconjs.</span>CompositeUnsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Desc">
            function <span class="apidocSignatureSpan">baconjs.</span>Desc
            <span class="apidocSignatureSpan">(context, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher">
            function <span class="apidocSignatureSpan">baconjs.</span>Dispatcher
            <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End">
            function <span class="apidocSignatureSpan">baconjs.</span>End
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error">
            function <span class="apidocSignatureSpan">baconjs.</span>Error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event">
            function <span class="apidocSignatureSpan">baconjs.</span>Event
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream">
            function <span class="apidocSignatureSpan">baconjs.</span>EventStream
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial">
            function <span class="apidocSignatureSpan">baconjs.</span>Initial
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next">
            function <span class="apidocSignatureSpan">baconjs.</span>Next
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable">
            function <span class="apidocSignatureSpan">baconjs.</span>Observable
            <span class="apidocSignatureSpan">(desc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property">
            function <span class="apidocSignatureSpan">baconjs.</span>Property
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.combineAsArray">
            function <span class="apidocSignatureSpan">baconjs.</span>combineAsArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.combineTemplate">
            function <span class="apidocSignatureSpan">baconjs.</span>combineTemplate
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.combineWith">
            function <span class="apidocSignatureSpan">baconjs.</span>combineWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.constant">
            function <span class="apidocSignatureSpan">baconjs.</span>constant
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromArray">
            function <span class="apidocSignatureSpan">baconjs.</span>fromArray
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromBinder">
            function <span class="apidocSignatureSpan">baconjs.</span>fromBinder
            <span class="apidocSignatureSpan">(binder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromCallback">
            function <span class="apidocSignatureSpan">baconjs.</span>fromCallback
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromESObservable">
            function <span class="apidocSignatureSpan">baconjs.</span>fromESObservable
            <span class="apidocSignatureSpan">(_observable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromEvent">
            function <span class="apidocSignatureSpan">baconjs.</span>fromEvent
            <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromEventTarget">
            function <span class="apidocSignatureSpan">baconjs.</span>fromEventTarget
            <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromNodeCallback">
            function <span class="apidocSignatureSpan">baconjs.</span>fromNodeCallback
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromPoll">
            function <span class="apidocSignatureSpan">baconjs.</span>fromPoll
            <span class="apidocSignatureSpan">(delay, poll)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.fromPromise">
            function <span class="apidocSignatureSpan">baconjs.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, abort)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.groupSimultaneous">
            function <span class="apidocSignatureSpan">baconjs.</span>groupSimultaneous
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.interval">
            function <span class="apidocSignatureSpan">baconjs.</span>interval
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.later">
            function <span class="apidocSignatureSpan">baconjs.</span>later
            <span class="apidocSignatureSpan">(delay, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.mergeAll">
            function <span class="apidocSignatureSpan">baconjs.</span>mergeAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.never">
            function <span class="apidocSignatureSpan">baconjs.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.onValues">
            function <span class="apidocSignatureSpan">baconjs.</span>onValues
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.once">
            function <span class="apidocSignatureSpan">baconjs.</span>once
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.repeat">
            function <span class="apidocSignatureSpan">baconjs.</span>repeat
            <span class="apidocSignatureSpan">(generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.repeatedly">
            function <span class="apidocSignatureSpan">baconjs.</span>repeatedly
            <span class="apidocSignatureSpan">(delay, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.retry">
            function <span class="apidocSignatureSpan">baconjs.</span>retry
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.sequentially">
            function <span class="apidocSignatureSpan">baconjs.</span>sequentially
            <span class="apidocSignatureSpan">(delay, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.spy">
            function <span class="apidocSignatureSpan">baconjs.</span>spy
            <span class="apidocSignatureSpan">(spy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.try">
            function <span class="apidocSignatureSpan">baconjs.</span>try
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.update">
            function <span class="apidocSignatureSpan">baconjs.</span>update
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.when">
            function <span class="apidocSignatureSpan">baconjs.</span>when
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.zipAsArray">
            function <span class="apidocSignatureSpan">baconjs.</span>zipAsArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.zipWith">
            function <span class="apidocSignatureSpan">baconjs.</span>zipWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Bacon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Bus.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>CompositeUnsubscribe.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Desc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Dispatcher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>End.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Error.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Event.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>EventStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Initial.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Next.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Observable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Property.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>UpdateBarrier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>scheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.</span>more</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.</span>noMore</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Bacon">module baconjs.Bacon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Bus">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Bus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.CompositeUnsubscribe">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>CompositeUnsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Desc">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Desc
            <span class="apidocSignatureSpan">(context, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Dispatcher">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Dispatcher
            <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.End">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>End
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Error">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Event">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Event
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.EventStream">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>EventStream
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Initial">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Initial
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Next">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Next
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Observable">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Observable
            <span class="apidocSignatureSpan">(desc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.Property">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Property
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.combineAsArray">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineAsArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.combineTemplate">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineTemplate
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.combineWith">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.constant">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>constant
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromArray">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromArray
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromBinder">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromBinder
            <span class="apidocSignatureSpan">(binder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromCallback">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromCallback
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromESObservable">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromESObservable
            <span class="apidocSignatureSpan">(_observable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromEvent">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromEvent
            <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromEventTarget">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromEventTarget
            <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromNodeCallback">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromNodeCallback
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromPoll">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromPoll
            <span class="apidocSignatureSpan">(delay, poll)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.fromPromise">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, abort)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.groupSimultaneous">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>groupSimultaneous
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.interval">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>interval
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.later">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>later
            <span class="apidocSignatureSpan">(delay, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.mergeAll">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>mergeAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.never">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.onValues">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>onValues
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.once">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>once
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.repeat">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>repeat
            <span class="apidocSignatureSpan">(generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.repeatedly">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>repeatedly
            <span class="apidocSignatureSpan">(delay, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.retry">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>retry
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.sequentially">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>sequentially
            <span class="apidocSignatureSpan">(delay, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.spy">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>spy
            <span class="apidocSignatureSpan">(spy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.toString">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.try">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>try
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.update">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>update
            <span class="apidocSignatureSpan">(initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.when">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>when
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.zipAsArray">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>zipAsArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bacon.zipWith">
            function <span class="apidocSignatureSpan">baconjs.Bacon.</span>zipWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.</span>Bacon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.Bacon.</span>UpdateBarrier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.Bacon.</span>_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.Bacon.</span>scheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.Bacon.</span>more</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.Bacon.</span>noMore</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baconjs.Bacon.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Bus">module baconjs.Bus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.Bus">
            function <span class="apidocSignatureSpan">baconjs.</span>Bus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Bus.prototype">module baconjs.Bus.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.end">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.error">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.guardedSink">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>guardedSink
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.plug">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>plug
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.push">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>push
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.subscribeAll">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>subscribeAll
            <span class="apidocSignatureSpan">(newSink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.subscribeInput">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>subscribeInput
            <span class="apidocSignatureSpan">(subscription)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.unsubAll">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>unsubAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Bus.prototype.unsubscribeInput">
            function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>unsubscribeInput
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.CompositeUnsubscribe">module baconjs.CompositeUnsubscribe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.CompositeUnsubscribe">
            function <span class="apidocSignatureSpan">baconjs.</span>CompositeUnsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.CompositeUnsubscribe.prototype">module baconjs.CompositeUnsubscribe.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.add">
            function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>add
            <span class="apidocSignatureSpan">(subscription)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.count">
            function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.empty">
            function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.remove">
            function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>remove
            <span class="apidocSignatureSpan">(unsub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Desc">module baconjs.Desc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Desc.Desc">
            function <span class="apidocSignatureSpan">baconjs.</span>Desc
            <span class="apidocSignatureSpan">(context, method, args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baconjs.Desc.</span>empty</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Desc.prototype">module baconjs.Desc.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Desc.prototype.</span>_isDesc</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Desc.prototype.deps">
            function <span class="apidocSignatureSpan">baconjs.Desc.prototype.</span>deps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Desc.prototype.toString">
            function <span class="apidocSignatureSpan">baconjs.Desc.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Dispatcher">module baconjs.Dispatcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.Dispatcher">
            function <span class="apidocSignatureSpan">baconjs.</span>Dispatcher
            <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Dispatcher.prototype">module baconjs.Dispatcher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.handleEvent">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>handleEvent
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.hasSubscribers">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>hasSubscribers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.push">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>push
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.pushIt">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>pushIt
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.pushToSubscriptions">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>pushToSubscriptions
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.removeSub">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>removeSub
            <span class="apidocSignatureSpan">(subscription)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.subscribe">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Dispatcher.prototype.unsubscribeFromSource">
            function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>unsubscribeFromSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.End">module baconjs.End</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End.End">
            function <span class="apidocSignatureSpan">baconjs.</span>End
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.End.prototype">module baconjs.End.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End.prototype.apply">
            function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End.prototype.fmap">
            function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>fmap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End.prototype.isEnd">
            function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>isEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.End.prototype.toString">
            function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Error">module baconjs.Error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error.Error">
            function <span class="apidocSignatureSpan">baconjs.</span>Error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Error.prototype">module baconjs.Error.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error.prototype.apply">
            function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error.prototype.fmap">
            function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>fmap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error.prototype.isError">
            function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>isError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Error.prototype.toString">
            function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Event">module baconjs.Event</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.Event">
            function <span class="apidocSignatureSpan">baconjs.</span>Event
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Event.prototype">module baconjs.Event.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>_isEvent</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.filter">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>filter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.hasValue">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>hasValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.inspect">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.isEnd">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.isError">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.isEvent">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isEvent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.isInitial">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isInitial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.isNext">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Event.prototype.log">
            function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.EventStream">module baconjs.EventStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.EventStream">
            function <span class="apidocSignatureSpan">baconjs.</span>EventStream
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.EventStream.prototype">module baconjs.EventStream.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>_isEventStream</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.buffer">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>buffer
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.bufferWithCount">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithCount
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.bufferWithTime">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithTime
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.bufferWithTimeOrCount">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithTimeOrCount
            <span class="apidocSignatureSpan">(delay, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.concat">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>concat
            <span class="apidocSignatureSpan">(right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.delayChanges">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>delayChanges
            <span class="apidocSignatureSpan">(desc, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.flatScan">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>flatScan
            <span class="apidocSignatureSpan">(seed, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.holdWhen">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>holdWhen
            <span class="apidocSignatureSpan">(valve)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.merge">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>merge
            <span class="apidocSignatureSpan">(right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.sampledBy">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>sampledBy
            <span class="apidocSignatureSpan">(sampler, combinator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.skipUntil">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>skipUntil
            <span class="apidocSignatureSpan">(starter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.skipWhile">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.startWith">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>startWith
            <span class="apidocSignatureSpan">(seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.takeUntil">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>takeUntil
            <span class="apidocSignatureSpan">(stopper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.toEventStream">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>toEventStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.toProperty">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>toProperty
            <span class="apidocSignatureSpan">(initValue_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.EventStream.prototype.withHandler">
            function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>withHandler
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Initial">module baconjs.Initial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial.Initial">
            function <span class="apidocSignatureSpan">baconjs.</span>Initial
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Initial.prototype">module baconjs.Initial.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>_isInitial</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial.prototype.apply">
            function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>apply
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial.prototype.isInitial">
            function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>isInitial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial.prototype.isNext">
            function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>isNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Initial.prototype.toNext">
            function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>toNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Next">module baconjs.Next</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.Next">
            function <span class="apidocSignatureSpan">baconjs.</span>Next
            <span class="apidocSignatureSpan">(valueF, eager)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Next.prototype">module baconjs.Next.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>_isNext</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.apply">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>apply
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.filter">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>filter
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.fmap">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>fmap
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.hasValue">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>hasValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.isNext">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>isNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.log">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.toString">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Next.prototype.value">
            function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>value
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Observable">module baconjs.Observable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.Observable">
            function <span class="apidocSignatureSpan">baconjs.</span>Observable
            <span class="apidocSignatureSpan">(desc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Observable.prototype">module baconjs.Observable.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>_isObservable</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.assign">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>assign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.awaiting">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>awaiting
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.bufferingThrottle">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>bufferingThrottle
            <span class="apidocSignatureSpan">(minimumInterval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.combine">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>combine
            <span class="apidocSignatureSpan">(other, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.debounce">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>debounce
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.debounceImmediate">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>debounceImmediate
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.decode">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>decode
            <span class="apidocSignatureSpan">(cases)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.delay">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>delay
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.deps">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>deps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.diff">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>diff
            <span class="apidocSignatureSpan">(start, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.doAction">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doAction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.doEnd">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.doError">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.doLog">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.endOnError">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>endOnError
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.errors">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>errors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.filter">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>filter
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.first">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.firstToPromise">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>firstToPromise
            <span class="apidocSignatureSpan">(PromiseCtr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMap">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMapConcat">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMapError">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapError
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMapFirst">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapFirst
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMapLatest">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.flatMapWithConcurrencyLimit">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapWithConcurrencyLimit
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.fold">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>fold
            <span class="apidocSignatureSpan">(seed, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.forEach">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>forEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.groupBy">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>groupBy
            <span class="apidocSignatureSpan">(keyF)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.inspect">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.internalDeps">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>internalDeps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.last">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.log">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.map">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>map
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.mapEnd">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>mapEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.mapError">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>mapError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.name">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>name
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.not">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.onEnd">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.onError">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.onValue">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.onValues">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onValues
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.reduce">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>reduce
            <span class="apidocSignatureSpan">(seed, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.scan">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>scan
            <span class="apidocSignatureSpan">(seed, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.skip">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skip
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.skipDuplicates">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skipDuplicates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.skipErrors">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skipErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.slidingWindow">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>slidingWindow
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.subscribe">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.subscribeInternal">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>subscribeInternal
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.take">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>take
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.takeWhile">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>takeWhile
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.throttle">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>throttle
            <span class="apidocSignatureSpan">(delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.toESObservable">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toESObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.toPromise">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toPromise
            <span class="apidocSignatureSpan">(PromiseCtr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.toString">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.withDescription">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>withDescription
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.withStateMachine">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>withStateMachine
            <span class="apidocSignatureSpan">(initState, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Observable.prototype.zip">
            function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>zip
            <span class="apidocSignatureSpan">(other, f)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Property">module baconjs.Property</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.Property">
            function <span class="apidocSignatureSpan">baconjs.</span>Property
            <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.Property.prototype">module baconjs.Property.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>_isProperty</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.and">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.bufferingThrottle">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>bufferingThrottle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.changes">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.delayChanges">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>delayChanges
            <span class="apidocSignatureSpan">(desc, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.or">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.sample">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>sample
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.sampledBy">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>sampledBy
            <span class="apidocSignatureSpan">(sampler, combinator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.startWith">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>startWith
            <span class="apidocSignatureSpan">(seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.takeUntil">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>takeUntil
            <span class="apidocSignatureSpan">(stopper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.toEventStream">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>toEventStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.toProperty">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>toProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.Property.prototype.withHandler">
            function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>withHandler
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.UpdateBarrier">module baconjs.UpdateBarrier</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.afterTransaction">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>afterTransaction
            <span class="apidocSignatureSpan">(obs, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.currentEventId">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>currentEventId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.hasWaiters">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>hasWaiters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.inTransaction">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>inTransaction
            <span class="apidocSignatureSpan">(event, context, f, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.whenDoneWith">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>whenDoneWith
            <span class="apidocSignatureSpan">(obs, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.UpdateBarrier.wrappedSubscribe">
            function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>wrappedSubscribe
            <span class="apidocSignatureSpan">(obs, sink)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs._">module baconjs._</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.all">
            function <span class="apidocSignatureSpan">baconjs._.</span>all
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.always">
            function <span class="apidocSignatureSpan">baconjs._.</span>always
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.any">
            function <span class="apidocSignatureSpan">baconjs._.</span>any
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.bind">
            function <span class="apidocSignatureSpan">baconjs._.</span>bind
            <span class="apidocSignatureSpan">(fn, me)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.cached">
            function <span class="apidocSignatureSpan">baconjs._.</span>cached
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.contains">
            function <span class="apidocSignatureSpan">baconjs._.</span>contains
            <span class="apidocSignatureSpan">(xs, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.each">
            function <span class="apidocSignatureSpan">baconjs._.</span>each
            <span class="apidocSignatureSpan">(xs, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.empty">
            function <span class="apidocSignatureSpan">baconjs._.</span>empty
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.filter">
            function <span class="apidocSignatureSpan">baconjs._.</span>filter
            <span class="apidocSignatureSpan">(f, xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.flatMap">
            function <span class="apidocSignatureSpan">baconjs._.</span>flatMap
            <span class="apidocSignatureSpan">(f, xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.fold">
            function <span class="apidocSignatureSpan">baconjs._.</span>fold
            <span class="apidocSignatureSpan">(xs, seed, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.head">
            function <span class="apidocSignatureSpan">baconjs._.</span>head
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.id">
            function <span class="apidocSignatureSpan">baconjs._.</span>id
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.indexOf">
            function <span class="apidocSignatureSpan">baconjs._.</span>indexOf
            <span class="apidocSignatureSpan">(xs, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.indexWhere">
            function <span class="apidocSignatureSpan">baconjs._.</span>indexWhere
            <span class="apidocSignatureSpan">(xs, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.isFunction">
            function <span class="apidocSignatureSpan">baconjs._.</span>isFunction
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.last">
            function <span class="apidocSignatureSpan">baconjs._.</span>last
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.map">
            function <span class="apidocSignatureSpan">baconjs._.</span>map
            <span class="apidocSignatureSpan">(f, xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.negate">
            function <span class="apidocSignatureSpan">baconjs._.</span>negate
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.remove">
            function <span class="apidocSignatureSpan">baconjs._.</span>remove
            <span class="apidocSignatureSpan">(x, xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.tail">
            function <span class="apidocSignatureSpan">baconjs._.</span>tail
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.toArray">
            function <span class="apidocSignatureSpan">baconjs._.</span>toArray
            <span class="apidocSignatureSpan">(xs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.toString">
            function <span class="apidocSignatureSpan">baconjs._.</span>toString
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs._.without">
            function <span class="apidocSignatureSpan">baconjs._.</span>without
            <span class="apidocSignatureSpan">(x, xs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baconjs.scheduler">module baconjs.scheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.scheduler.clearInterval">
            function <span class="apidocSignatureSpan">baconjs.scheduler.</span>clearInterval
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.scheduler.clearTimeout">
            function <span class="apidocSignatureSpan">baconjs.scheduler.</span>clearTimeout
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.scheduler.now">
            function <span class="apidocSignatureSpan">baconjs.scheduler.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.scheduler.setInterval">
            function <span class="apidocSignatureSpan">baconjs.scheduler.</span>setInterval
            <span class="apidocSignatureSpan">(f, i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baconjs.scheduler.setTimeout">
            function <span class="apidocSignatureSpan">baconjs.scheduler.</span>setTimeout
            <span class="apidocSignatureSpan">(f, d)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs" id="apidoc.module.baconjs">module baconjs</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Bus" id="apidoc.element.baconjs.Bus">
        function <span class="apidocSignatureSpan">baconjs.</span>Bus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bus() {
  if (!(this instanceof Bus)) {
    return new Bus();
  }

  this.unsubAll = _.bind(this.unsubAll, this);
  this.subscribeAll = _.bind(this.subscribeAll, this);
  this.guardedSink = _.bind(this.guardedSink, this);

  this.sink = undefined;
  this.subscriptions = [];
  this.ended = false;
  EventStream.call(this, new Bacon.Desc(Bacon, "Bus", []), this.subscribeAll);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.<span class="apidocCodeKeywordSpan">Bus</span>()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus
) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.

Bacon.fromBinder for custom streams
-----------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe" id="apidoc.element.baconjs.CompositeUnsubscribe">
        function <span class="apidocSignatureSpan">baconjs.</span>CompositeUnsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompositeUnsubscribe() {
  var ss = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];

  this.unsubscribe = _.bind(this.unsubscribe, this);
  this.unsubscribed = false;
  this.subscriptions = [];
  this.starting = [];
  for (var i = 0, s; i &lt; ss.length; i++) {
    s = ss[i];
    this.add(s);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Desc" id="apidoc.element.baconjs.Desc">
        function <span class="apidocSignatureSpan">baconjs.</span>Desc
        <span class="apidocSignatureSpan">(context, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Desc(context, method, args) {
  this.context = context;
  this.method = method;
  this.args = args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher" id="apidoc.element.baconjs.Dispatcher">
        function <span class="apidocSignatureSpan">baconjs.</span>Dispatcher
        <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dispatcher(_subscribe, _handleEvent) {
  this._subscribe = _subscribe;
  this._handleEvent = _handleEvent;
  this.subscribe = _.bind(this.subscribe, this);
  this.handleEvent = _.bind(this.handleEvent, this);
  this.pushing = false;
  this.ended = false;
  this.prevError = undefined;
  this.unsubSrc = undefined;
  this.subscriptions = [];
  this.queue = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.End" id="apidoc.element.baconjs.End">
        function <span class="apidocSignatureSpan">baconjs.</span>End
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function End() {
  if (!(this instanceof End)) {
    return new End();
  }
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.<span class="apidocCodeKeywordSpan">End</span>()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Error" id="apidoc.element.baconjs.Error">
        function <span class="apidocSignatureSpan">baconjs.</span>Error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error(error) {
  if (!(this instanceof Error)) {
    return new Error(error);
  }
  this.error = error;
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.<span class="apidocCodeKeywordSpan">Error</span>("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event" id="apidoc.element.baconjs.Event">
        function <span class="apidocSignatureSpan">baconjs.</span>Event
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Event() {
  this.id = ++eventIdCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream" id="apidoc.element.baconjs.EventStream">
        function <span class="apidocSignatureSpan">baconjs.</span>EventStream
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventStream(desc, subscribe, handler) {
  if (!(this instanceof EventStream)) {
    return new EventStream(desc, subscribe, handler);
  }
  if (_.isFunction(desc)) {
    handler = subscribe;
    subscribe = desc;
    desc = Desc.empty;
  }
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new Dispatcher(subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single
-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.<span class="apidocCodeKeywordSpan">EventStream</span>(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream
(subscribe)") creates an [`EventStream`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Initial" id="apidoc.element.baconjs.Initial">
        function <span class="apidocSignatureSpan">baconjs.</span>Initial
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Initial(valueF, eager) {
  if (!(this instanceof Initial)) {
    return new Initial(valueF, eager);
  }
  Next.call(this, valueF, eager);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next" id="apidoc.element.baconjs.Next">
        function <span class="apidocSignatureSpan">baconjs.</span>Next
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Next(valueF, eager) {
  if (!(this instanceof Next)) {
    return new Next(valueF, eager);
  }

  Event.call(this);

  if (!eager &amp;&amp; _.isFunction(valueF) || (valueF != null ? valueF._isNext : void 0)) {
    this.valueF = valueF;
    this.valueInternal = void 0;
  } else {
    this.valueF = void 0;
    this.valueInternal = valueF;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.<span class="apidocCodeKeywordSpan">Next</span>(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable" id="apidoc.element.baconjs.Observable">
        function <span class="apidocSignatureSpan">baconjs.</span>Observable
        <span class="apidocSignatureSpan">(desc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable(desc) {
  this.desc = desc;
  this.id = ++idCounter;
  this.initialDesc = this.desc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property" id="apidoc.element.baconjs.Property">
        function <span class="apidocSignatureSpan">baconjs.</span>Property
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Property(desc, subscribe, handler) {
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new PropertyDispatcher(this, subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.combineAsArray" id="apidoc.element.baconjs.combineAsArray">
        function <span class="apidocSignatureSpan">baconjs.</span>combineAsArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineAsArray = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    var sources = [];
    for (var i = 0; i &lt; streams.length; i++) {
      var stream = isObservable(streams[i]) ? streams[i] : Bacon.constant(streams[i]);
      sources.push(new Source(stream, true));
    }
    return withDesc(new Bacon.Desc(Bacon, "combineAsArray", streams), Bacon.when(sources, function () {
      for (var _len9 = arguments.length, xs = Array(_len9), _key9 = 0; _key9 &lt; _len9; _key9++) {
        xs[_key9] = arguments[_key9];
      }

      return xs;
    }).toProperty());
  } else {
    return Bacon.constant([]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
given value will be used as the initial value. If the property has an
initial value of its own, the given value will be ignored.

Combining multiple streams and properties
-----------------------------------------

&lt;a name="bacon-combineasarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineAsArray</span>(streams)`](#bacon-combineasarray "Bacon.combineAsArray(streams
)") combines Properties, EventStreams and
constant values so that the result Property will have an array of all
property values as its value. The input array may contain both Properties
and EventStreams. In the latter case, the stream is first converted into
a Property and then combined with the other properties.

&lt;a name="bacon-combineasarray-multiple-streams"&gt;&lt;/a&gt;
[`Bacon.combineAsArray(s1, s2...)`](#bacon-combineasarray-multiple-streams "Bacon.combineAsArray(s1, s2...)") just like
 above, but with streams
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.combineTemplate" id="apidoc.element.baconjs.combineTemplate">
        function <span class="apidocSignatureSpan">baconjs.</span>combineTemplate
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineTemplate = function (template) {
  function current(ctxStack) {
    return ctxStack[ctxStack.length - 1];
  }
  function setValue(ctxStack, key, value) {
    current(ctxStack)[key] = value;
    return value;
  }
  function applyStreamValue(key, index) {
    return function (ctxStack, values) {
      return setValue(ctxStack, key, values[index]);
    };
  }
  function constantValue(key, value) {
    return function (ctxStack) {
      return setValue(ctxStack, key, value);
    };
  }

  function mkContext(template) {
    return isArray(template) ? [] : {};
  }

  function pushContext(key, value) {
    return function (ctxStack) {
      var newContext = mkContext(value);
      setValue(ctxStack, key, newContext);
      return ctxStack.push(newContext);
    };
  }

  function compile(key, value) {
    if (isObservable(value)) {
      streams.push(value);
      return funcs.push(applyStreamValue(key, streams.length - 1));
    } else if (value &amp;&amp; (value.constructor == Object || value.constructor == Array)) {
      var popContext = function (ctxStack) {
        return ctxStack.pop();
      };
      funcs.push(pushContext(key, value));
      compileTemplate(value);
      return funcs.push(popContext);
    } else {
      return funcs.push(constantValue(key, value));
    }
  }

  function combinator(values) {
    var rootContext = mkContext(template);
    var ctxStack = [rootContext];
    for (var i = 0, f; i &lt; funcs.length; i++) {
      f = funcs[i];
      f(ctxStack, values);
    }
    return rootContext;
  }

  function compileTemplate(template) {
    return _.each(template, compile);
  }

  var funcs = [];
  var streams = [];

  compileTemplate(template);

  return withDesc(new Bacon.Desc(Bacon, "combineTemplate", [template]), Bacon.combineAsArray(streams).map(combinator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-combinewith-streams-array-f-last"&gt;&lt;/a&gt;
[`Bacon.combineWith(streams, f)`](#bacon-combinewith-streams-array-f-last "Bacon.combineWith(streams, f)") like above

&lt;a name="bacon-combinewith-f-last"&gt;&lt;/a&gt;
[`Bacon.combineWith(stream1, stream2..., f)`](#bacon-combinewith-f-last "Bacon.combineWith(stream1, stream2 ..., f)")
like above

&lt;a name="bacon-combinetemplate"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineTemplate</span>(template)`](#bacon-combinetemplate "Bacon.combineTemplate
(template)") combines Properties, EventStreams and
constant values using a template
object. For instance, assuming you've got streams or properties named
`password`, `username`, `firstname` and `lastname`, you can do

```js
var password, username, firstname, lastname; // &lt;- properties or streams
var loginInfo = Bacon.combineTemplate({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.combineWith" id="apidoc.element.baconjs.combineWith">
        function <span class="apidocSignatureSpan">baconjs.</span>combineWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineWith = function () {
  var _argumentsToObservablesAndFunction = argumentsToObservablesAndFunction(arguments);

  var streams = _argumentsToObservablesAndFunction[0];
  var f = _argumentsToObservablesAndFunction[1];

  var desc = new Bacon.Desc(Bacon, "combineWith", [f].concat(streams));
  return withDesc(desc, Bacon.combineAsArray(streams).map(function (values) {
    return f.apply(undefined, values);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
stream = Bacon.once(2)
constant = 3
Bacon.combineAsArray(property, stream, constant)
# produces the value [1,2,3]
```

&lt;a name="bacon-combinewith"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineWith</span>(f, stream1, stream2...)`](#bacon-combinewith "Bacon.combineWith
(f, stream1, stream2 ...)") combines given *n* Properties,
EventStreams and constant values using the given n-ary function `f(v1, v2 ...)`.
To calculate the current sum of three numeric Properties, you can do

```js
function sum3(x,y,z) { return x + y + z }
Bacon.combineWith(sum3, p1, p2, p3)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.constant" id="apidoc.element.baconjs.constant">
        function <span class="apidocSignatureSpan">baconjs.</span>constant
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function (value) {
  return new Property(new Bacon.Desc(Bacon, "constant", [value]), function (sink) {
    sink(initialEvent(value));
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
second.

You can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.<span class="apidocCodeKeywordSpan">constant</span>('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').log();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromArray" id="apidoc.element.baconjs.fromArray">
        function <span class="apidocSignatureSpan">baconjs.</span>fromArray
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (values) {
  assertArray(values);
  if (!values.length) {
    return withDesc(new Bacon.Desc(Bacon, "fromArray", values), Bacon.never());
  } else {
    var i = 0;
    var stream = new EventStream(new Bacon.Desc(Bacon, "fromArray", [values]), function (sink) {
      var unsubd = false;
      var reply = Bacon.more;
      var pushing = false;
      var pushNeeded = false;
      function push() {
        pushNeeded = true;
        if (pushing) {
          return;
        }
        pushing = true;
        while (pushNeeded) {
          pushNeeded = false;
          if (reply !== Bacon.noMore &amp;&amp; !unsubd) {
            var value = values[i++];
            reply = sink(toEvent(value));
            if (reply !== Bacon.noMore) {
              if (i === values.length) {
                sink(endEvent());
              } else {
                UpdateBarrier.afterTransaction(stream, push);
              }
            }
          }
        }
        pushing = false;
        return pushing;
      };

      push();
      return function () {
        unsubd = true;
        return unsubd;
      };
    });
    return stream;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.Error("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromArray</span>(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event
[A] | A]) : EventStream[A]") creates an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.interval(interval, value)`](#bacon-interval "Bacon.interval(interval : Number, value : A) : EventStream[A]") repeats
 the single element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromBinder" id="apidoc.element.baconjs.fromBinder">
        function <span class="apidocSignatureSpan">baconjs.</span>fromBinder
        <span class="apidocSignatureSpan">(binder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBinder = function (binder) {
  var eventTransformer = arguments.length &lt;= 1 || arguments[1] === undefined ? _.id : arguments[1];

  var desc = new Bacon.Desc(Bacon, "fromBinder", [binder, eventTransformer]);
  return new EventStream(desc, function (sink) {
    var unbound = false;
    var shouldUnbind = false;
    var unbind = function () {
      if (!unbound) {
        if (typeof unbinder !== "undefined" &amp;&amp; unbinder !== null) {
          unbinder();
          return unbound = true;
        } else {
          return shouldUnbind = true;
        }
      }
    };
    var unbinder = binder(function () {
      var ref;

      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 &lt; _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var value = eventTransformer.apply(this, args);
      if (!(isArray(value) &amp;&amp; ((ref = _.last(value)) != null ? ref._isEvent : undefined))) {
        value = [value];
      }
      var reply = Bacon.more;
      for (var i = 0, event; i &lt; value.length; i++) {
        event = value[i];
        reply = sink(event = toEvent(event));
        if (reply === Bacon.noMore || event.isEnd()) {
          unbind();
          return reply;
        }
      }
      return reply;
    });
    if (shouldUnbind) {
      unbind();
    }
    return unbind;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Bacon.fromBinder for custom streams
-----------------------------------

If none of the factory methods above apply, you may of course roll your own EventStream by using [`Bacon.fromBinder`](#bacon-frombinder
).

&lt;a name="bacon-frombinder"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromBinder</span>(subscribe)`](#bacon-frombinder "Bacon.fromBinder(subscribe)&amp;#
x22;) The parameter `subscribe` is a function that accepts a `sink` which is a function that your `subscribe` function can "
;push" events to.

For example:

```js
var stream = Bacon.fromBinder(function(sink) {
sink("first value")
sink([new Bacon.Next("2nd"), new Bacon.Next("3rd")])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromCallback" id="apidoc.element.baconjs.fromCallback">
        function <span class="apidocSignatureSpan">baconjs.</span>fromCallback
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromCallback = function (f) {
  for (var _len2 = arguments.length, args = Array(_len2 &gt; 1 ? _len2 - 1 : 0), _key2 = 1; _key2 &lt; _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (typeof f === "object" &amp;&amp; args.length) {
    var context = f;
    var methodName = args[0];
    f = function () {
      return context[methodName].apply(context, arguments);
    };
    args = args.slice(1);
  }
  return wrapped.apply(undefined, [f].concat(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
events' parameters.

```js
Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
```

&lt;a name="bacon-fromcallback"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromCallback</span>(f [, args...])`](#bacon-fromcallback "Bacon.fromCallback(f : (
A -&gt; void) -&gt; void [, args...]) : EventStream[A]") creates an EventStream from a function that
accepts a callback. The function is supposed to call its callback just
once. For example:

```js
Bacon.fromCallback(function(callback) {
setTimeout(function() {
  callback("Bacon!")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromESObservable" id="apidoc.element.baconjs.fromESObservable">
        function <span class="apidocSignatureSpan">baconjs.</span>fromESObservable
        <span class="apidocSignatureSpan">(_observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromESObservable = function (_observable) {
  var observable;
  if (_observable[symbol("observable")]) {
    observable = _observable[symbol("observable")]();
  } else {
    observable = _observable;
  }

  var desc = new Bacon.Desc(Bacon, "fromESObservable", [observable]);
  return new Bacon.EventStream(desc, function (sink) {
    var cancel = observable.subscribe({
      error: function () {
        sink(new Bacon.Error());
        sink(new Bacon.End());
      },
      next: function (value) {
        sink(new Bacon.Next(value, true));
      },
      complete: function () {
        sink(new Bacon.End());
      }
    });

    if (cancel.unsubscribe) {
      return function () {
        cancel.unsubscribe();
      };
    } else {
      return cancel;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
read.onError(function(error) { console.log("Reading failed: " + error); });
read.onValue(function(value) { console.log("Read contents: " + value); });
```

&lt;a name="bacon-fromesobservable"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromESObservable</span>(observable)`](#bacon-fromesobservable "Bacon.fromESObservable
(observable : ESObservable[A]) : EventStream[A]") creates an EventStream from an
[ES Observable](https://github.com/tc39/proposal-observable). Input can be any
ES Observable implementation including RxJS and Kefir.

&lt;a name="bacon-fromnodecallback-object"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(object, methodName [, args...])`](#bacon-fromnodecallback-object "Bacon.fromNodeCallback(object, methodName
 [, args...])") a variant of fromNodeCallback which calls the named method of a given object.

&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromEvent" id="apidoc.element.baconjs.fromEvent">
        function <span class="apidocSignatureSpan">baconjs.</span>fromEvent
        <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (target, eventName, eventTransformer) {
  var _findHandlerMethods = findHandlerMethods(target);

  var sub = _findHandlerMethods[0];
  var unsub = _findHandlerMethods[1];

  var desc = new Bacon.Desc(Bacon, "fromEvent", [target, eventName]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    sub.call(target, eventName, handler);
    return function () {
      return unsub.call(target, eventName, handler);
    };
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromEvent</span>(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon
.fromEvent(target : EventTarget | EventEmitter, eventName : String [, eventTransformer]) : EventStream") creates an EventStream
 from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.

```js
Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromEventTarget" id="apidoc.element.baconjs.fromEventTarget">
        function <span class="apidocSignatureSpan">baconjs.</span>fromEventTarget
        <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventTarget = function (target, eventName, eventTransformer) {
  var _findHandlerMethods = findHandlerMethods(target);

  var sub = _findHandlerMethods[0];
  var unsub = _findHandlerMethods[1];

  var desc = new Bacon.Desc(Bacon, "fromEvent", [target, eventName]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    sub.call(target, eventName, handler);
    return function () {
      return unsub.call(target, eventName, handler);
    };
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromNodeCallback" id="apidoc.element.baconjs.fromNodeCallback">
        function <span class="apidocSignatureSpan">baconjs.</span>fromNodeCallback
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNodeCallback = function (f) {
  for (var _len2 = arguments.length, args = Array(_len2 &gt; 1 ? _len2 - 1 : 0), _key2 = 1; _key2 &lt; _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (typeof f === "object" &amp;&amp; args.length) {
    var context = f;
    var methodName = args[0];
    f = function () {
      return context[methodName].apply(context, arguments);
    };
    args = args.slice(1);
  }
  return wrapped.apply(undefined, [f].concat(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}, bacon, 'rules').log();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

&lt;a name="bacon-fromnodecallback"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromNodeCallback</span>(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback
(f : (E -&gt; A -&gt; void) -&gt; void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#
bacon-fromcallback),
except that it expects the callback to be called in the Node.js convention:
`callback(error, data)`, where error is null if everything is fine. For example:

```js
var Bacon = require('baconjs').Bacon,
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromPoll" id="apidoc.element.baconjs.fromPoll">
        function <span class="apidocSignatureSpan">baconjs.</span>fromPoll
        <span class="apidocSignatureSpan">(delay, poll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPoll = function (delay, poll) {
  var desc = new Bacon.Desc(Bacon, "fromPoll", [delay, poll]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    var id = Bacon.scheduler.setInterval(handler, delay);
    return function () {
      return Bacon.scheduler.clearInterval(id);
    };
  }, poll));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[ES Observable](https://github.com/tc39/proposal-observable). Input can be any
ES Observable implementation including RxJS and Kefir.

&lt;a name="bacon-fromnodecallback-object"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(object, methodName [, args...])`](#bacon-fromnodecallback-object "Bacon.fromNodeCallback(object, methodName
 [, args...])") a variant of fromNodeCallback which calls the named method of a given object.

&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromPoll</span>(interval, f)`](#bacon-frompoll "Bacon.fromPoll(interval : Number
, f : -&gt; Event[A]) : EventStream[A]") polls given function with given interval.
Function should return Events: either [`Bacon.Next`](#bacon-next) or [`Bacon.End`](#bacon-end). Polling occurs only
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.fromPromise" id="apidoc.element.baconjs.fromPromise">
        function <span class="apidocSignatureSpan">baconjs.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, abort)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, abort) {
  var eventTransformer = arguments.length &lt;= 2 || arguments[2] === undefined ? valueAndEnd : arguments[2];

  return withDesc(new Bacon.Desc(Bacon, "fromPromise", [promise]), Bacon.fromBinder(function (handler) {
    var bound = promise.then(handler, function (e) {
      return handler(new Error(e));
    });
    if (bound &amp;&amp; typeof bound.done === "function") {
      bound.done();
    }

    if (abort) {
      return function () {
        if (typeof promise.abort === "function") {
          return promise.abort();
        }
      };
    } else {
      return function () {};
    }
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
$("#my-div").asEventStream("click", ".more-specific-selector")
$("#my-div").asEventStream("click", ".more-specific-selector", function(event, args) { return args
[0] })
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromPromise</span>(promise [, abort] [, eventTransformer])`](#bacon-frompromise "
;Bacon.fromPromise(promise : Promise[A] [, abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream
from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.groupSimultaneous" id="apidoc.element.baconjs.groupSimultaneous">
        function <span class="apidocSignatureSpan">baconjs.</span>groupSimultaneous
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupSimultaneous = function () {
  for (var _len5 = arguments.length, streams = Array(_len5), _key5 = 0; _key5 &lt; _len5; _key5++) {
    streams[_key5] = arguments[_key5];
  }

  if (streams.length === 1 &amp;&amp; isArray(streams[0])) {
    streams = streams[0];
  }
  var sources = (function () {
    var result = [];
    for (var i = 0, s; i &lt; streams.length; i++) {
      s = streams[i];
      result.push(new BufferingSource(s));
    }
    return result;
  })();
  return withDesc(new Bacon.Desc(Bacon, "groupSimultaneous", streams), Bacon.when(sources, function () {
    for (var _len6 = arguments.length, xs = Array(_len6), _key6 = 0; _key6 &lt; _len6; _key6++) {
      xs[_key6] = arguments[_key6];
    }

    return xs;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.interval" id="apidoc.element.baconjs.interval">
        function <span class="apidocSignatureSpan">baconjs.</span>interval
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (delay) {
  var value = arguments.length &lt;= 1 || arguments[1] === undefined ? {} : arguments[1];

  return withDesc(new Bacon.Desc(Bacon, "interval", [delay, value]), Bacon.fromPoll(delay, function () {
    return nextEvent(value);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">interval</span>(interval, value)`](#bacon-interval "Bacon.interval(interval : Number
, value : A) : EventStream[A]") repeats the single element
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.sequentially(interval, values)`](#bacon-sequentially "Bacon.sequentially(interval : Number, values : Array[A]) : EventStream
[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.later" id="apidoc.element.baconjs.later">
        function <span class="apidocSignatureSpan">baconjs.</span>later
        <span class="apidocSignatureSpan">(delay, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">later = function (delay, value) {
  return withDesc(new Bacon.Desc(Bacon, "later", [delay, value]), Bacon.fromBinder(function (sink) {
    var sender = function () {
      return sink([value, endEvent()]);
    };
    var id = Bacon.scheduler.setTimeout(sender, delay);
    return function () {
      return Bacon.scheduler.clearTimeout(id);
    };
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The example will produce values 0, 1 and 2.

&lt;a name="bacon-never"&gt;&lt;/a&gt;
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">later</span>(delay, value)`](#bacon-later "Bacon.later(delay : Number, value :
A) : EventStream[A]") creates a single-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.mergeAll" id="apidoc.element.baconjs.mergeAll">
        function <span class="apidocSignatureSpan">baconjs.</span>mergeAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeAll = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    return new EventStream(new Bacon.Desc(Bacon, "mergeAll", streams), function (sink) {
      var ends = 0;
      var smartSink = function (obs) {
        return function (unsubBoth) {
          return obs.dispatcher.subscribe(function (event) {
            if (event.isEnd()) {
              ends++;
              if (ends === streams.length) {
                return sink(endEvent());
              } else {
                return Bacon.more;
              }
            } else {
              var reply = sink(event);
              if (reply === Bacon.noMore) {
                unsubBoth();
              }
              return reply;
            }
          });
        };
      };
      var sinks = _.map(smartSink, streams);
      return new Bacon.CompositeUnsubscribe(sinks).unsubscribe;
    });
  } else {
    return Bacon.never();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you need the result as an [`EventStream`](#eventstream) you might want to use [`property.changes()`](#property-changes)

```js
Bacon.combineWith(function(v1,v2) { .. }, stream1, stream2).changes()
```

&lt;a name="bacon-mergeall"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">mergeAll</span>(streams)`](#bacon-mergeall "Bacon.mergeAll(streams)") merges
 given array of EventStreams.
`Bacon.mergeAll(stream1, stream2 ...)` merges given EventStreams.

&lt;a name="bacon-zipasarray"&gt;&lt;/a&gt;
[`Bacon.zipAsArray(streams)`](#bacon-zipasarray "Bacon.zipAsArray(streams)") zips the array of EventStreams / Properties
 in to a new
EventStream that will have an array of values from each source as
its value. Zipping means that events from each source are combined
pairwise so that the 1st event from each source is published first, then
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.never" id="apidoc.element.baconjs.never">
        function <span class="apidocSignatureSpan">baconjs.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
  return new EventStream(describe(Bacon, "never"), function (sink) {
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}).log()
```

The example will produce values 0, 1 and 2.

&lt;a name="bacon-never"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">never</span>()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream
 that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single
-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.onValues" id="apidoc.element.baconjs.onValues">
        function <span class="apidocSignatureSpan">baconjs.</span>onValues
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onValues = function () {
  return Bacon.combineAsArray(Array.prototype.slice.call(arguments, 0, arguments.length - 1)).onValues(arguments[arguments.length
 - 1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
received, instead of [`Event`](#event) objects.
The [Function Construction rules](#function-construction-rules) below apply here.
Just like `subscribe`, this method returns a function for unsubscribing.
`stream.onValue` and `property.onValue` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

&lt;a name="observable-onvalues"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">onValues</span>(f)`](#observable-onvalues "observable.onValues(f)") like
 [`onValue`](#stream-onvalue), but splits the value (assuming its an
array) as function arguments to `f`.

&lt;a name="observable-onerror"&gt;&lt;/a&gt;
[`observable.onError(f)`](#observable-onerror "observable.onError(@ : Observable[A], f : Error -&gt; void) : Unsubscriber
") subscribes a callback to error events. The function will be called for each error in the stream.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-onend"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.once" id="apidoc.element.baconjs.once">
        function <span class="apidocSignatureSpan">baconjs.</span>once
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (value) {
  return new EventStream(new Desc(Bacon, "once", [value]), function (sink) {
    sink(toEvent(value));
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
[`Bacon.fromPoll(interval, f)`](#bacon-frompoll "Bacon.fromPoll(interval : Number, f : -&gt; Event[A]) : EventStream[A]&amp;#
x22;) polls given function with given interval.
Function should return Events: either [`Bacon.Next`](#bacon-next) or [`Bacon.End`](#bacon-end). Polling occurs only
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">once</span>(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream
[A]") creates an EventStream that delivers the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.Error("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.repeat" id="apidoc.element.baconjs.repeat">
        function <span class="apidocSignatureSpan">baconjs.</span>repeat
        <span class="apidocSignatureSpan">(generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (generator) {
  var index = 0;
  return Bacon.fromBinder(function (sink) {
    var flag = false;
    var reply = Bacon.more;
    var unsub = function () {};
    function handleEvent(event) {
      if (event.isEnd()) {
        if (!flag) {
          return flag = true;
        } else {
          return subscribeNext();
        }
      } else {
        return reply = sink(event);
      }
    };
    function subscribeNext() {
      var next;
      flag = true;
      while (flag &amp;&amp; reply !== Bacon.noMore) {
        next = generator(index++);
        flag = false;
        if (next) {
          unsub = next.subscribeInternal(handleEvent);
        } else {
          sink(endEvent());
        }
      }
      return flag = true;
    };
    subscribeNext();
    return function () {
      return unsub();
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.repeatedly(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval : Number, values : Array[A]) : EventStream
[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

&lt;a name="bacon-repeat"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">repeat</span>(fn)`](#bacon-repeat "Bacon.repeat(fn: Number -&gt; Observable[A
]): EventStream[A]") Calls generator function which is expected to return an observable. The returned EventStream contains
values and errors from the spawned observable. When the spawned observable ends, the generator is called
again to spawn a new observable.

This is repeated until the generator returns a falsy value
(such as `undefined` or `false`).

The generator function is called with one argument â€” iteration number starting from `0`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.repeatedly" id="apidoc.element.baconjs.repeatedly">
        function <span class="apidocSignatureSpan">baconjs.</span>repeatedly
        <span class="apidocSignatureSpan">(delay, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeatedly = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "repeatedly", [delay, values]), Bacon.fromPoll(delay, function () {
    return values[index++ % values.length];
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.sequentially(interval, values)`](#bacon-sequentially "Bacon.sequentially(interval : Number, values : Array[A]) : EventStream
[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">repeatedly</span>(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval
 : Number, values : Array[A]) : EventStream[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

&lt;a name="bacon-repeat"&gt;&lt;/a&gt;
[`Bacon.repeat(fn)`](#bacon-repeat "Bacon.repeat(fn: Number -&gt; Observable[A]): EventStream[A]") Calls generator function
 which is expected to return an observable. The returned EventStream contains
values and errors from the spawned observable. When the spawned observable ends, the generator is called
again to spawn a new observable.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.retry" id="apidoc.element.baconjs.retry">
        function <span class="apidocSignatureSpan">baconjs.</span>retry
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (options) {
  if (!_.isFunction(options.source)) {
    throw new Exception("'source' option has to be a function");
  }
  var source = options.source;
  var retries = options.retries || 0;
  var retriesDone = 0;
  var delay = options.delay || function () {
    return 0;
  };
  var isRetryable = options.isRetryable || function () {
    return true;
  };
  var finished = false;
  var error = null;

  return withDesc(new Bacon.Desc(Bacon, "retry", [options]), Bacon.repeat(function (count) {
    function valueStream() {
      return source(count).endOnError().withHandler(function (event) {
        if (event.isError()) {
          error = event;
          if (!(isRetryable(error.error) &amp;&amp; (retries === 0 || retriesDone &lt; retries))) {
            finished = true;
            return this.push(event);
          }
        } else {
          if (event.hasValue()) {
            error = null;
            finished = true;
          }
          return this.push(event);
        }
      });
    }

    if (finished) {
      return null;
    } else if (error) {
      var context = {
        error: error.error,
        retriesDone: retriesDone
      };
      var pause = Bacon.later(delay(context)).filter(false);
      retriesDone++;
      return pause.concat(Bacon.once().flatMap(valueStream));
    } else {
      return valueStream();
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Bacon.js doesn't currently generate any [`Error`](#bacon-error) events itself (except when
converting errors using Bacon.fromPromise). Error
events definitely would be generated by streams derived from IO sources
such as AJAX calls.

&lt;a name="bacon-retry"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">retry</span>(options)`](#bacon-retry "Bacon.retry(options)") is used to retry
 the call when there is an [`Error`](#bacon-error) event in the stream produced by the `source` function.

The two required option parameters are:

* `source`, a function that produces an Observable. The function gets attempt number (starting from zero) as its argument.
* `retries`, the number of times to retry the `source` function _in addition to the initial attempt_. Use the value o (zero) for
 retrying indefinitely.

Additionally, one may pass in one or both of the following callbacks:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.sequentially" id="apidoc.element.baconjs.sequentially">
        function <span class="apidocSignatureSpan">baconjs.</span>sequentially
        <span class="apidocSignatureSpan">(delay, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequentially = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "sequentially", [delay, values]), Bacon.fromPoll(delay, function () {
    var value = values[index++];
    if (index &lt; values.length) {
      return value;
    } else if (index === values.length) {
      return [value, endEvent()];
    } else {
      return endEvent();
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.interval(interval, value)`](#bacon-interval "Bacon.interval(interval : Number, value : A) : EventStream[A]") repeats
 the single element
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">sequentially</span>(interval, values)`](#bacon-sequentially "Bacon.sequentially
(interval : Number, values : Array[A]) : EventStream[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.repeatedly(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval : Number, values : Array[A]) : EventStream
[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.spy" id="apidoc.element.baconjs.spy">
        function <span class="apidocSignatureSpan">baconjs.</span>spy
        <span class="apidocSignatureSpan">(spy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spy = function (spy) {
  return spies.push(spy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example, for `Bacon.fromArray([1,2,3]).desc` you'd get

    { context: Bacon, method: "fromArray", args: [[1,2,3]] }

Notice that this is a field, not a function.

&lt;a name="bacon-spy"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">spy</span>(f)`](#bacon-spy "Bacon.spy(f)")
Adds your function as a "spy" that will get notified on all new Observables.
This will allow a visualization/analytis tool to spy on all Bacon activity.

Cleaning up
-----------

As described above, a subscriber can signal the loss of interest in new events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.try" id="apidoc.element.baconjs.try">
        function <span class="apidocSignatureSpan">baconjs.</span>try
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">try = function (f) {
  return function (value) {
    try {
      return Bacon.once(f(value));
    } catch (e) {
      return new Bacon.Error(e);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Note also that Bacon.js combinators do not catch errors that are thrown.
Especially [`map`](#observable-map) doesn't do so. If you want to map things
and wrap caught errors into Error events, you can do the following:

```js
wrapped = source.flatMap(Bacon.<span class="apidocCodeKeywordSpan">try</span>(dangerousOperation))
```

For example, you can use `Bacon.try` to handle JSON parse errors:

```js
var jsonStream = Bacon
.once('{"this is invalid json"')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.update" id="apidoc.element.baconjs.update">
        function <span class="apidocSignatureSpan">baconjs.</span>update
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (initial) {
  function lateBindFirst(f) {
    return function () {
      for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 &lt; _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }

      return function (i) {
        return f.apply(undefined, [i].concat(args));
      };
    };
  }

  for (var _len21 = arguments.length, patterns = Array(_len21 &gt; 1 ? _len21 - 1 : 0), _key21 = 1; _key21 &lt; _len21; _key21++) {
    patterns[_key21 - 1] = arguments[_key21];
  }

  var i = patterns.length - 1;
  while (i &gt; 0) {
    if (!(patterns[i] instanceof Function)) {
      patterns[i] = _.always(patterns[i]);
    }
    patterns[i] = lateBindFirst(patterns[i]);
    i = i - 2;
  }
  return withDesc(new Bacon.Desc(Bacon, "update", [initial].concat(patterns)), Bacon.when.apply(Bacon, patterns).scan(initial, function
 (x, f) {
    return f(x);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
convert it into an EventStream using [`property.changes()`](#property-changes) or [`property.toEventStream()`](#property-toeventstream
)

&lt;a name="bacon-update"&gt;&lt;/a&gt;
[`Bacon.update`](#bacon-update "Bacon.update") creates a Property from an initial value and updates the value based on
 multiple inputs.
The inputs are defined similarly to [`Bacon.when`](#bacon-when), like this:

```js
var result = Bacon.<span class="apidocCodeKeywordSpan">update</span>(
  initial,
  [x,y,z], function(previous,x,y,z) { ... },
  [x,y],   function(previous,x,y) { ... })
```

As input, each function above will get the previous value of the `result` Property, along with values from the listed Observables
.
The value returned by the function will be used as the next value of `result`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.when" id="apidoc.element.baconjs.when">
        function <span class="apidocSignatureSpan">baconjs.</span>when
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function () {
  if (arguments.length === 0) {
    return Bacon.never();
  }
  var len = arguments.length;
  var usage = "when: expecting arguments in the form (Observable+,function)+";

  assert(usage, len % 2 === 0);
  var sources = [];
  var pats = [];
  var i = 0;
  var patterns = [];
  while (i &lt; len) {
    patterns[i] = arguments[i];
    patterns[i + 1] = arguments[i + 1];
    var patSources = _.toArray(arguments[i]);
    var f = constantToFunction(arguments[i + 1]);
    var pat = { f: f, ixs: [] };
    var triggerFound = false;
    for (var j = 0, s; j &lt; patSources.length; j++) {
      s = patSources[j];
      var index = _.indexOf(sources, s);
      if (!triggerFound) {
        triggerFound = Source.isTrigger(s);
      }
      if (index &lt; 0) {
        sources.push(s);
        index = sources.length - 1;
      }
      for (var k = 0, ix; k &lt; pat.ixs.length; k++) {
        ix = pat.ixs[k];
        if (ix.index === index) {
          ix.count++;
        }
      }
      pat.ixs.push({ index: index, count: 1 });
    }

    assert("At least one EventStream required", triggerFound || !patSources.length);

    if (patSources.length &gt; 0) {
      pats.push(pat);
    }
    i = i + 2;
  }

  if (!sources.length) {
    return Bacon.never();
  }

  sources = _.map(Source.fromObservable, sources);
  var needsBarrier = _.any(sources, function (s) {
    return s.flatten;
  }) &amp;&amp; containsDuplicateDeps(_.map(function (s) {
    return s.obs;
  }, sources));

  var desc = new Bacon.Desc(Bacon, "when", patterns);
  var resultStream = new EventStream(desc, function (sink) {
    var triggers = [];
    var ends = false;
    var match = function (p) {
      for (var i1 = 0, i; i1 &lt; p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].hasAtLeast(i.count)) {
          return false;
        }
      }
      return true;
    };
    var cannotSync = function (source) {
      return !source.sync || source.ended;
    };
    var cannotMatch = function (p) {
      for (var i1 = 0, i; i1 &lt; p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].mayHave(i.count)) {
          return true;
        }
      }
    };
    var nonFlattened = function (trigger) {
      return !trigger.source.flatten;
    };
    var part = function (source) {
      return function (unsubAll) {
        var flushLater = function () {
          return UpdateBarrier.whenDoneWith(resultStream, flush);
        };
        var flushWhileTriggers = function () {
          if (triggers.length &gt; 0) {
            var reply = Bacon.more;
            var trigger = triggers.pop();
            for (var i1 = 0, p; i1 &lt; pats.length; i1++) {
              p = pats[i1];
              if (match(p)) {
                var events = (function () {
                  var result = [];
                  for (var i2 = 0, i; i2 &lt; p.ixs.length; i2++) {
                    i = p.ixs[i2];
                    result.push(sources[i.index].consume());
                  }
                  return result;
                })();
                reply = sink(trigger.e.apply(function () {
                  var _p;

                  var values = (function () {
                    var result = [];
                    for (var i2 = 0, event; i2 &lt; events.length; i2++) {
                      event = events[i2];
                      result.push(event.value());
                    }
                    return result;
                  })();

                  return (_p = p).f.apply(_p, values);
                }));
                if (triggers.length) {
                  triggers = _.filter(nonFlattened, triggers);
                }
                if (reply === Bacon.noMore) {
                  return reply;
                } else {
                  return flushWhileTriggers();
                }
              }
            }
          } else {
            return Bacon.more;
          }
        };
        var flush = function () {
          var reply = flushWhileTriggers();
          if (ends) {
            if (_.all(sources, cannotSync) || _.all(pats, cannotMatch)) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-when"&gt;&lt;/a&gt;
[`Bacon.when`](#bacon-when "Bacon.when") Consider implementing a game with discrete time ticks. We want to
handle key-events synchronized on tick-events, with at most one key
event handled per tick. If there are no key events, we want to just
process a tick.

```js
  Bacon.<span class="apidocCodeKeywordSpan">when</span>(
    [tick, keyEvent], function(_, k) { handleKeyEvent(k); return handleTick(); },
    [tick], handleTick)
```

Order is important here. If the [tick] patterns had been written
first, this would have been tried first, and preferred at each tick.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.zipAsArray" id="apidoc.element.baconjs.zipAsArray">
        function <span class="apidocSignatureSpan">baconjs.</span>zipAsArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipAsArray = function () {
  for (var _len23 = arguments.length, args = Array(_len23), _key23 = 0; _key23 &lt; _len23; _key23++) {
    args[_key23] = arguments[_key23];
  }

  var streams = argumentsToObservables(args);
  return withDesc(new Bacon.Desc(Bacon, "zipAsArray", streams), Bacon.zipWith(streams, function () {
    for (var _len24 = arguments.length, xs = Array(_len24), _key24 = 0; _key24 &lt; _len24; _key24++) {
      xs[_key24] = arguments[_key24];
    }

    return xs;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

&lt;a name="bacon-mergeall"&gt;&lt;/a&gt;
[`Bacon.mergeAll(streams)`](#bacon-mergeall "Bacon.mergeAll(streams)") merges given array of EventStreams.
`Bacon.mergeAll(stream1, stream2 ...)` merges given EventStreams.

&lt;a name="bacon-zipasarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">zipAsArray</span>(streams)`](#bacon-zipasarray "Bacon.zipAsArray(streams)")
zips the array of EventStreams / Properties in to a new
EventStream that will have an array of values from each source as
its value. Zipping means that events from each source are combined
pairwise so that the 1st event from each source is published first, then
the 2nd event from each. The results will be published as soon as there
is a value from each source.

Be careful not to have too much "drift" between streams. If one stream
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.zipWith" id="apidoc.element.baconjs.zipWith">
        function <span class="apidocSignatureSpan">baconjs.</span>zipWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipWith = function () {
  for (var _len25 = arguments.length, args = Array(_len25), _key25 = 0; _key25 &lt; _len25; _key25++) {
    args[_key25] = arguments[_key25];
  }

  var observablesAndFunction = argumentsToObservablesAndFunction(args);
  var streams = observablesAndFunction[0];
  var f = observablesAndFunction[1];

  streams = _.map(function (s) {
    return s.toEventStream();
  }, streams);
  return withDesc(new Bacon.Desc(Bacon, "zipWith", [f].concat(streams)), Bacon.when(streams, f));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

&lt;a name="bacon-zipasarray-multiple-streams"&gt;&lt;/a&gt;
[`Bacon.zipAsArray(stream1, stream2...)`](#bacon-zipasarray-multiple-streams "Bacon.zipAsArray(stream1, stream2...)")
just like above, but with sources
provided as a list of arguments as opposed to a single array.

&lt;a name="bacon-zipwith"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">zipWith</span>(streams, f)`](#bacon-zipwith "Bacon.zipWith(streams, f)") like
 [`zipAsArray`](#bacon-zipasarray) but uses the given n-ary
function to combine the n values from n sources, instead of returning them in an Array.

&lt;a name="bacon-zipwith-f-first"&gt;&lt;/a&gt;
[`Bacon.zipWith(f, streams)`](#bacon-zipwith-f-first "Bacon.zipWith(f, streams)") like [`zipAsArray`](#bacon-zipasarray
) but uses the given n-ary
function to combine the n values from n sources, instead of returning them in an Array.

&lt;a name="bacon-zipwith-f-first-varargs"&gt;&lt;/a&gt;
...</pre></li>
    </ul>








































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Bacon" id="apidoc.module.baconjs.Bacon">module baconjs.Bacon</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Bus" id="apidoc.element.baconjs.Bacon.Bus">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Bus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bus() {
  if (!(this instanceof Bus)) {
    return new Bus();
  }

  this.unsubAll = _.bind(this.unsubAll, this);
  this.subscribeAll = _.bind(this.subscribeAll, this);
  this.guardedSink = _.bind(this.guardedSink, this);

  this.sink = undefined;
  this.subscriptions = [];
  this.ended = false;
  EventStream.call(this, new Bacon.Desc(Bacon, "Bus", []), this.subscribeAll);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.<span class="apidocCodeKeywordSpan">Bus</span>()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus
) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.

Bacon.fromBinder for custom streams
-----------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.CompositeUnsubscribe" id="apidoc.element.baconjs.Bacon.CompositeUnsubscribe">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>CompositeUnsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompositeUnsubscribe() {
  var ss = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];

  this.unsubscribe = _.bind(this.unsubscribe, this);
  this.unsubscribed = false;
  this.subscriptions = [];
  this.starting = [];
  for (var i = 0, s; i &lt; ss.length; i++) {
    s = ss[i];
    this.add(s);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Desc" id="apidoc.element.baconjs.Bacon.Desc">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Desc
        <span class="apidocSignatureSpan">(context, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Desc(context, method, args) {
  this.context = context;
  this.method = method;
  this.args = args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Dispatcher" id="apidoc.element.baconjs.Bacon.Dispatcher">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Dispatcher
        <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dispatcher(_subscribe, _handleEvent) {
  this._subscribe = _subscribe;
  this._handleEvent = _handleEvent;
  this.subscribe = _.bind(this.subscribe, this);
  this.handleEvent = _.bind(this.handleEvent, this);
  this.pushing = false;
  this.ended = false;
  this.prevError = undefined;
  this.unsubSrc = undefined;
  this.subscriptions = [];
  this.queue = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.End" id="apidoc.element.baconjs.Bacon.End">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>End
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function End() {
  if (!(this instanceof End)) {
    return new End();
  }
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.<span class="apidocCodeKeywordSpan">End</span>()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Error" id="apidoc.element.baconjs.Bacon.Error">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error(error) {
  if (!(this instanceof Error)) {
    return new Error(error);
  }
  this.error = error;
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.<span class="apidocCodeKeywordSpan">Error</span>("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Event" id="apidoc.element.baconjs.Bacon.Event">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Event
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Event() {
  this.id = ++eventIdCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.EventStream" id="apidoc.element.baconjs.Bacon.EventStream">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>EventStream
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventStream(desc, subscribe, handler) {
  if (!(this instanceof EventStream)) {
    return new EventStream(desc, subscribe, handler);
  }
  if (_.isFunction(desc)) {
    handler = subscribe;
    subscribe = desc;
    desc = Desc.empty;
  }
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new Dispatcher(subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single
-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.<span class="apidocCodeKeywordSpan">EventStream</span>(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream
(subscribe)") creates an [`EventStream`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Initial" id="apidoc.element.baconjs.Bacon.Initial">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Initial
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Initial(valueF, eager) {
  if (!(this instanceof Initial)) {
    return new Initial(valueF, eager);
  }
  Next.call(this, valueF, eager);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Next" id="apidoc.element.baconjs.Bacon.Next">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Next
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Next(valueF, eager) {
  if (!(this instanceof Next)) {
    return new Next(valueF, eager);
  }

  Event.call(this);

  if (!eager &amp;&amp; _.isFunction(valueF) || (valueF != null ? valueF._isNext : void 0)) {
    this.valueF = valueF;
    this.valueInternal = void 0;
  } else {
    this.valueF = void 0;
    this.valueInternal = valueF;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.<span class="apidocCodeKeywordSpan">Next</span>(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Observable" id="apidoc.element.baconjs.Bacon.Observable">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Observable
        <span class="apidocSignatureSpan">(desc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable(desc) {
  this.desc = desc;
  this.id = ++idCounter;
  this.initialDesc = this.desc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.Property" id="apidoc.element.baconjs.Bacon.Property">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>Property
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Property(desc, subscribe, handler) {
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new PropertyDispatcher(this, subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.combineAsArray" id="apidoc.element.baconjs.Bacon.combineAsArray">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineAsArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineAsArray = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    var sources = [];
    for (var i = 0; i &lt; streams.length; i++) {
      var stream = isObservable(streams[i]) ? streams[i] : Bacon.constant(streams[i]);
      sources.push(new Source(stream, true));
    }
    return withDesc(new Bacon.Desc(Bacon, "combineAsArray", streams), Bacon.when(sources, function () {
      for (var _len9 = arguments.length, xs = Array(_len9), _key9 = 0; _key9 &lt; _len9; _key9++) {
        xs[_key9] = arguments[_key9];
      }

      return xs;
    }).toProperty());
  } else {
    return Bacon.constant([]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
given value will be used as the initial value. If the property has an
initial value of its own, the given value will be ignored.

Combining multiple streams and properties
-----------------------------------------

&lt;a name="bacon-combineasarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineAsArray</span>(streams)`](#bacon-combineasarray "Bacon.combineAsArray(streams
)") combines Properties, EventStreams and
constant values so that the result Property will have an array of all
property values as its value. The input array may contain both Properties
and EventStreams. In the latter case, the stream is first converted into
a Property and then combined with the other properties.

&lt;a name="bacon-combineasarray-multiple-streams"&gt;&lt;/a&gt;
[`Bacon.combineAsArray(s1, s2...)`](#bacon-combineasarray-multiple-streams "Bacon.combineAsArray(s1, s2...)") just like
 above, but with streams
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.combineTemplate" id="apidoc.element.baconjs.Bacon.combineTemplate">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineTemplate
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineTemplate = function (template) {
  function current(ctxStack) {
    return ctxStack[ctxStack.length - 1];
  }
  function setValue(ctxStack, key, value) {
    current(ctxStack)[key] = value;
    return value;
  }
  function applyStreamValue(key, index) {
    return function (ctxStack, values) {
      return setValue(ctxStack, key, values[index]);
    };
  }
  function constantValue(key, value) {
    return function (ctxStack) {
      return setValue(ctxStack, key, value);
    };
  }

  function mkContext(template) {
    return isArray(template) ? [] : {};
  }

  function pushContext(key, value) {
    return function (ctxStack) {
      var newContext = mkContext(value);
      setValue(ctxStack, key, newContext);
      return ctxStack.push(newContext);
    };
  }

  function compile(key, value) {
    if (isObservable(value)) {
      streams.push(value);
      return funcs.push(applyStreamValue(key, streams.length - 1));
    } else if (value &amp;&amp; (value.constructor == Object || value.constructor == Array)) {
      var popContext = function (ctxStack) {
        return ctxStack.pop();
      };
      funcs.push(pushContext(key, value));
      compileTemplate(value);
      return funcs.push(popContext);
    } else {
      return funcs.push(constantValue(key, value));
    }
  }

  function combinator(values) {
    var rootContext = mkContext(template);
    var ctxStack = [rootContext];
    for (var i = 0, f; i &lt; funcs.length; i++) {
      f = funcs[i];
      f(ctxStack, values);
    }
    return rootContext;
  }

  function compileTemplate(template) {
    return _.each(template, compile);
  }

  var funcs = [];
  var streams = [];

  compileTemplate(template);

  return withDesc(new Bacon.Desc(Bacon, "combineTemplate", [template]), Bacon.combineAsArray(streams).map(combinator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-combinewith-streams-array-f-last"&gt;&lt;/a&gt;
[`Bacon.combineWith(streams, f)`](#bacon-combinewith-streams-array-f-last "Bacon.combineWith(streams, f)") like above

&lt;a name="bacon-combinewith-f-last"&gt;&lt;/a&gt;
[`Bacon.combineWith(stream1, stream2..., f)`](#bacon-combinewith-f-last "Bacon.combineWith(stream1, stream2 ..., f)")
like above

&lt;a name="bacon-combinetemplate"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineTemplate</span>(template)`](#bacon-combinetemplate "Bacon.combineTemplate
(template)") combines Properties, EventStreams and
constant values using a template
object. For instance, assuming you've got streams or properties named
`password`, `username`, `firstname` and `lastname`, you can do

```js
var password, username, firstname, lastname; // &lt;- properties or streams
var loginInfo = Bacon.combineTemplate({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.combineWith" id="apidoc.element.baconjs.Bacon.combineWith">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>combineWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combineWith = function () {
  var _argumentsToObservablesAndFunction = argumentsToObservablesAndFunction(arguments);

  var streams = _argumentsToObservablesAndFunction[0];
  var f = _argumentsToObservablesAndFunction[1];

  var desc = new Bacon.Desc(Bacon, "combineWith", [f].concat(streams));
  return withDesc(desc, Bacon.combineAsArray(streams).map(function (values) {
    return f.apply(undefined, values);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
stream = Bacon.once(2)
constant = 3
Bacon.combineAsArray(property, stream, constant)
# produces the value [1,2,3]
```

&lt;a name="bacon-combinewith"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">combineWith</span>(f, stream1, stream2...)`](#bacon-combinewith "Bacon.combineWith
(f, stream1, stream2 ...)") combines given *n* Properties,
EventStreams and constant values using the given n-ary function `f(v1, v2 ...)`.
To calculate the current sum of three numeric Properties, you can do

```js
function sum3(x,y,z) { return x + y + z }
Bacon.combineWith(sum3, p1, p2, p3)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.constant" id="apidoc.element.baconjs.Bacon.constant">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>constant
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function (value) {
  return new Property(new Bacon.Desc(Bacon, "constant", [value]), function (sink) {
    sink(initialEvent(value));
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
second.

You can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.<span class="apidocCodeKeywordSpan">constant</span>('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').log();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromArray" id="apidoc.element.baconjs.Bacon.fromArray">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromArray
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (values) {
  assertArray(values);
  if (!values.length) {
    return withDesc(new Bacon.Desc(Bacon, "fromArray", values), Bacon.never());
  } else {
    var i = 0;
    var stream = new EventStream(new Bacon.Desc(Bacon, "fromArray", [values]), function (sink) {
      var unsubd = false;
      var reply = Bacon.more;
      var pushing = false;
      var pushNeeded = false;
      function push() {
        pushNeeded = true;
        if (pushing) {
          return;
        }
        pushing = true;
        while (pushNeeded) {
          pushNeeded = false;
          if (reply !== Bacon.noMore &amp;&amp; !unsubd) {
            var value = values[i++];
            reply = sink(toEvent(value));
            if (reply !== Bacon.noMore) {
              if (i === values.length) {
                sink(endEvent());
              } else {
                UpdateBarrier.afterTransaction(stream, push);
              }
            }
          }
        }
        pushing = false;
        return pushing;
      };

      push();
      return function () {
        unsubd = true;
        return unsubd;
      };
    });
    return stream;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.Error("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromArray</span>(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event
[A] | A]) : EventStream[A]") creates an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.interval(interval, value)`](#bacon-interval "Bacon.interval(interval : Number, value : A) : EventStream[A]") repeats
 the single element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromBinder" id="apidoc.element.baconjs.Bacon.fromBinder">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromBinder
        <span class="apidocSignatureSpan">(binder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBinder = function (binder) {
  var eventTransformer = arguments.length &lt;= 1 || arguments[1] === undefined ? _.id : arguments[1];

  var desc = new Bacon.Desc(Bacon, "fromBinder", [binder, eventTransformer]);
  return new EventStream(desc, function (sink) {
    var unbound = false;
    var shouldUnbind = false;
    var unbind = function () {
      if (!unbound) {
        if (typeof unbinder !== "undefined" &amp;&amp; unbinder !== null) {
          unbinder();
          return unbound = true;
        } else {
          return shouldUnbind = true;
        }
      }
    };
    var unbinder = binder(function () {
      var ref;

      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 &lt; _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var value = eventTransformer.apply(this, args);
      if (!(isArray(value) &amp;&amp; ((ref = _.last(value)) != null ? ref._isEvent : undefined))) {
        value = [value];
      }
      var reply = Bacon.more;
      for (var i = 0, event; i &lt; value.length; i++) {
        event = value[i];
        reply = sink(event = toEvent(event));
        if (reply === Bacon.noMore || event.isEnd()) {
          unbind();
          return reply;
        }
      }
      return reply;
    });
    if (shouldUnbind) {
      unbind();
    }
    return unbind;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Bacon.fromBinder for custom streams
-----------------------------------

If none of the factory methods above apply, you may of course roll your own EventStream by using [`Bacon.fromBinder`](#bacon-frombinder
).

&lt;a name="bacon-frombinder"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromBinder</span>(subscribe)`](#bacon-frombinder "Bacon.fromBinder(subscribe)&amp;#
x22;) The parameter `subscribe` is a function that accepts a `sink` which is a function that your `subscribe` function can "
;push" events to.

For example:

```js
var stream = Bacon.fromBinder(function(sink) {
sink("first value")
sink([new Bacon.Next("2nd"), new Bacon.Next("3rd")])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromCallback" id="apidoc.element.baconjs.Bacon.fromCallback">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromCallback
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromCallback = function (f) {
  for (var _len2 = arguments.length, args = Array(_len2 &gt; 1 ? _len2 - 1 : 0), _key2 = 1; _key2 &lt; _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (typeof f === "object" &amp;&amp; args.length) {
    var context = f;
    var methodName = args[0];
    f = function () {
      return context[methodName].apply(context, arguments);
    };
    args = args.slice(1);
  }
  return wrapped.apply(undefined, [f].concat(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
events' parameters.

```js
Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
```

&lt;a name="bacon-fromcallback"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromCallback</span>(f [, args...])`](#bacon-fromcallback "Bacon.fromCallback(f : (
A -&gt; void) -&gt; void [, args...]) : EventStream[A]") creates an EventStream from a function that
accepts a callback. The function is supposed to call its callback just
once. For example:

```js
Bacon.fromCallback(function(callback) {
setTimeout(function() {
  callback("Bacon!")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromESObservable" id="apidoc.element.baconjs.Bacon.fromESObservable">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromESObservable
        <span class="apidocSignatureSpan">(_observable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromESObservable = function (_observable) {
  var observable;
  if (_observable[symbol("observable")]) {
    observable = _observable[symbol("observable")]();
  } else {
    observable = _observable;
  }

  var desc = new Bacon.Desc(Bacon, "fromESObservable", [observable]);
  return new Bacon.EventStream(desc, function (sink) {
    var cancel = observable.subscribe({
      error: function () {
        sink(new Bacon.Error());
        sink(new Bacon.End());
      },
      next: function (value) {
        sink(new Bacon.Next(value, true));
      },
      complete: function () {
        sink(new Bacon.End());
      }
    });

    if (cancel.unsubscribe) {
      return function () {
        cancel.unsubscribe();
      };
    } else {
      return cancel;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
read.onError(function(error) { console.log("Reading failed: " + error); });
read.onValue(function(value) { console.log("Read contents: " + value); });
```

&lt;a name="bacon-fromesobservable"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromESObservable</span>(observable)`](#bacon-fromesobservable "Bacon.fromESObservable
(observable : ESObservable[A]) : EventStream[A]") creates an EventStream from an
[ES Observable](https://github.com/tc39/proposal-observable). Input can be any
ES Observable implementation including RxJS and Kefir.

&lt;a name="bacon-fromnodecallback-object"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(object, methodName [, args...])`](#bacon-fromnodecallback-object "Bacon.fromNodeCallback(object, methodName
 [, args...])") a variant of fromNodeCallback which calls the named method of a given object.

&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromEvent" id="apidoc.element.baconjs.Bacon.fromEvent">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromEvent
        <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (target, eventName, eventTransformer) {
  var _findHandlerMethods = findHandlerMethods(target);

  var sub = _findHandlerMethods[0];
  var unsub = _findHandlerMethods[1];

  var desc = new Bacon.Desc(Bacon, "fromEvent", [target, eventName]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    sub.call(target, eventName, handler);
    return function () {
      return unsub.call(target, eventName, handler);
    };
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromEvent</span>(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon
.fromEvent(target : EventTarget | EventEmitter, eventName : String [, eventTransformer]) : EventStream") creates an EventStream
 from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.

```js
Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromEventTarget" id="apidoc.element.baconjs.Bacon.fromEventTarget">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromEventTarget
        <span class="apidocSignatureSpan">(target, eventName, eventTransformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventTarget = function (target, eventName, eventTransformer) {
  var _findHandlerMethods = findHandlerMethods(target);

  var sub = _findHandlerMethods[0];
  var unsub = _findHandlerMethods[1];

  var desc = new Bacon.Desc(Bacon, "fromEvent", [target, eventName]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    sub.call(target, eventName, handler);
    return function () {
      return unsub.call(target, eventName, handler);
    };
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromNodeCallback" id="apidoc.element.baconjs.Bacon.fromNodeCallback">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromNodeCallback
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNodeCallback = function (f) {
  for (var _len2 = arguments.length, args = Array(_len2 &gt; 1 ? _len2 - 1 : 0), _key2 = 1; _key2 &lt; _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (typeof f === "object" &amp;&amp; args.length) {
    var context = f;
    var methodName = args[0];
    f = function () {
      return context[methodName].apply(context, arguments);
    };
    args = args.slice(1);
  }
  return wrapped.apply(undefined, [f].concat(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}, bacon, 'rules').log();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

&lt;a name="bacon-fromnodecallback"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromNodeCallback</span>(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback
(f : (E -&gt; A -&gt; void) -&gt; void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#
bacon-fromcallback),
except that it expects the callback to be called in the Node.js convention:
`callback(error, data)`, where error is null if everything is fine. For example:

```js
var Bacon = require('baconjs').Bacon,
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromPoll" id="apidoc.element.baconjs.Bacon.fromPoll">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromPoll
        <span class="apidocSignatureSpan">(delay, poll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPoll = function (delay, poll) {
  var desc = new Bacon.Desc(Bacon, "fromPoll", [delay, poll]);
  return withDesc(desc, Bacon.fromBinder(function (handler) {
    var id = Bacon.scheduler.setInterval(handler, delay);
    return function () {
      return Bacon.scheduler.clearInterval(id);
    };
  }, poll));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[ES Observable](https://github.com/tc39/proposal-observable). Input can be any
ES Observable implementation including RxJS and Kefir.

&lt;a name="bacon-fromnodecallback-object"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(object, methodName [, args...])`](#bacon-fromnodecallback-object "Bacon.fromNodeCallback(object, methodName
 [, args...])") a variant of fromNodeCallback which calls the named method of a given object.

&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromPoll</span>(interval, f)`](#bacon-frompoll "Bacon.fromPoll(interval : Number
, f : -&gt; Event[A]) : EventStream[A]") polls given function with given interval.
Function should return Events: either [`Bacon.Next`](#bacon-next) or [`Bacon.End`](#bacon-end). Polling occurs only
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.fromPromise" id="apidoc.element.baconjs.Bacon.fromPromise">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, abort)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, abort) {
  var eventTransformer = arguments.length &lt;= 2 || arguments[2] === undefined ? valueAndEnd : arguments[2];

  return withDesc(new Bacon.Desc(Bacon, "fromPromise", [promise]), Bacon.fromBinder(function (handler) {
    var bound = promise.then(handler, function (e) {
      return handler(new Error(e));
    });
    if (bound &amp;&amp; typeof bound.done === "function") {
      bound.done();
    }

    if (abort) {
      return function () {
        if (typeof promise.abort === "function") {
          return promise.abort();
        }
      };
    } else {
      return function () {};
    }
  }, eventTransformer));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
$("#my-div").asEventStream("click", ".more-specific-selector")
$("#my-div").asEventStream("click", ".more-specific-selector", function(event, args) { return args
[0] })
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">fromPromise</span>(promise [, abort] [, eventTransformer])`](#bacon-frompromise "
;Bacon.fromPromise(promise : Promise[A] [, abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream
from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.groupSimultaneous" id="apidoc.element.baconjs.Bacon.groupSimultaneous">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>groupSimultaneous
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupSimultaneous = function () {
  for (var _len5 = arguments.length, streams = Array(_len5), _key5 = 0; _key5 &lt; _len5; _key5++) {
    streams[_key5] = arguments[_key5];
  }

  if (streams.length === 1 &amp;&amp; isArray(streams[0])) {
    streams = streams[0];
  }
  var sources = (function () {
    var result = [];
    for (var i = 0, s; i &lt; streams.length; i++) {
      s = streams[i];
      result.push(new BufferingSource(s));
    }
    return result;
  })();
  return withDesc(new Bacon.Desc(Bacon, "groupSimultaneous", streams), Bacon.when(sources, function () {
    for (var _len6 = arguments.length, xs = Array(_len6), _key6 = 0; _key6 &lt; _len6; _key6++) {
      xs[_key6] = arguments[_key6];
    }

    return xs;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.interval" id="apidoc.element.baconjs.Bacon.interval">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>interval
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (delay) {
  var value = arguments.length &lt;= 1 || arguments[1] === undefined ? {} : arguments[1];

  return withDesc(new Bacon.Desc(Bacon, "interval", [delay, value]), Bacon.fromPoll(delay, function () {
    return nextEvent(value);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">interval</span>(interval, value)`](#bacon-interval "Bacon.interval(interval : Number
, value : A) : EventStream[A]") repeats the single element
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.sequentially(interval, values)`](#bacon-sequentially "Bacon.sequentially(interval : Number, values : Array[A]) : EventStream
[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.later" id="apidoc.element.baconjs.Bacon.later">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>later
        <span class="apidocSignatureSpan">(delay, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">later = function (delay, value) {
  return withDesc(new Bacon.Desc(Bacon, "later", [delay, value]), Bacon.fromBinder(function (sink) {
    var sender = function () {
      return sink([value, endEvent()]);
    };
    var id = Bacon.scheduler.setTimeout(sender, delay);
    return function () {
      return Bacon.scheduler.clearTimeout(id);
    };
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The example will produce values 0, 1 and 2.

&lt;a name="bacon-never"&gt;&lt;/a&gt;
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">later</span>(delay, value)`](#bacon-later "Bacon.later(delay : Number, value :
A) : EventStream[A]") creates a single-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.mergeAll" id="apidoc.element.baconjs.Bacon.mergeAll">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>mergeAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeAll = function () {
  var streams = argumentsToObservables(arguments);
  if (streams.length) {
    return new EventStream(new Bacon.Desc(Bacon, "mergeAll", streams), function (sink) {
      var ends = 0;
      var smartSink = function (obs) {
        return function (unsubBoth) {
          return obs.dispatcher.subscribe(function (event) {
            if (event.isEnd()) {
              ends++;
              if (ends === streams.length) {
                return sink(endEvent());
              } else {
                return Bacon.more;
              }
            } else {
              var reply = sink(event);
              if (reply === Bacon.noMore) {
                unsubBoth();
              }
              return reply;
            }
          });
        };
      };
      var sinks = _.map(smartSink, streams);
      return new Bacon.CompositeUnsubscribe(sinks).unsubscribe;
    });
  } else {
    return Bacon.never();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you need the result as an [`EventStream`](#eventstream) you might want to use [`property.changes()`](#property-changes)

```js
Bacon.combineWith(function(v1,v2) { .. }, stream1, stream2).changes()
```

&lt;a name="bacon-mergeall"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">mergeAll</span>(streams)`](#bacon-mergeall "Bacon.mergeAll(streams)") merges
 given array of EventStreams.
`Bacon.mergeAll(stream1, stream2 ...)` merges given EventStreams.

&lt;a name="bacon-zipasarray"&gt;&lt;/a&gt;
[`Bacon.zipAsArray(streams)`](#bacon-zipasarray "Bacon.zipAsArray(streams)") zips the array of EventStreams / Properties
 in to a new
EventStream that will have an array of values from each source as
its value. Zipping means that events from each source are combined
pairwise so that the 1st event from each source is published first, then
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.never" id="apidoc.element.baconjs.Bacon.never">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
  return new EventStream(describe(Bacon, "never"), function (sink) {
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}).log()
```

The example will produce values 0, 1 and 2.

&lt;a name="bacon-never"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">never</span>()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream
 that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single
-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.onValues" id="apidoc.element.baconjs.Bacon.onValues">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>onValues
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onValues = function () {
  return Bacon.combineAsArray(Array.prototype.slice.call(arguments, 0, arguments.length - 1)).onValues(arguments[arguments.length
 - 1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
received, instead of [`Event`](#event) objects.
The [Function Construction rules](#function-construction-rules) below apply here.
Just like `subscribe`, this method returns a function for unsubscribing.
`stream.onValue` and `property.onValue` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

&lt;a name="observable-onvalues"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">onValues</span>(f)`](#observable-onvalues "observable.onValues(f)") like
 [`onValue`](#stream-onvalue), but splits the value (assuming its an
array) as function arguments to `f`.

&lt;a name="observable-onerror"&gt;&lt;/a&gt;
[`observable.onError(f)`](#observable-onerror "observable.onError(@ : Observable[A], f : Error -&gt; void) : Unsubscriber
") subscribes a callback to error events. The function will be called for each error in the stream.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-onend"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.once" id="apidoc.element.baconjs.Bacon.once">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>once
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (value) {
  return new EventStream(new Desc(Bacon, "once", [value]), function (sink) {
    sink(toEvent(value));
    sink(endEvent());
    return nop;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-frompoll"&gt;&lt;/a&gt;
[`Bacon.fromPoll(interval, f)`](#bacon-frompoll "Bacon.fromPoll(interval : Number, f : -&gt; Event[A]) : EventStream[A]&amp;#
x22;) polls given function with given interval.
Function should return Events: either [`Bacon.Next`](#bacon-next) or [`Bacon.End`](#bacon-end). Polling occurs only
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">once</span>(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream
[A]") creates an EventStream that delivers the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.Error("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.repeat" id="apidoc.element.baconjs.Bacon.repeat">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>repeat
        <span class="apidocSignatureSpan">(generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (generator) {
  var index = 0;
  return Bacon.fromBinder(function (sink) {
    var flag = false;
    var reply = Bacon.more;
    var unsub = function () {};
    function handleEvent(event) {
      if (event.isEnd()) {
        if (!flag) {
          return flag = true;
        } else {
          return subscribeNext();
        }
      } else {
        return reply = sink(event);
      }
    };
    function subscribeNext() {
      var next;
      flag = true;
      while (flag &amp;&amp; reply !== Bacon.noMore) {
        next = generator(index++);
        flag = false;
        if (next) {
          unsub = next.subscribeInternal(handleEvent);
        } else {
          sink(endEvent());
        }
      }
      return flag = true;
    };
    subscribeNext();
    return function () {
      return unsub();
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.repeatedly(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval : Number, values : Array[A]) : EventStream
[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

&lt;a name="bacon-repeat"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">repeat</span>(fn)`](#bacon-repeat "Bacon.repeat(fn: Number -&gt; Observable[A
]): EventStream[A]") Calls generator function which is expected to return an observable. The returned EventStream contains
values and errors from the spawned observable. When the spawned observable ends, the generator is called
again to spawn a new observable.

This is repeated until the generator returns a falsy value
(such as `undefined` or `false`).

The generator function is called with one argument â€” iteration number starting from `0`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.repeatedly" id="apidoc.element.baconjs.Bacon.repeatedly">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>repeatedly
        <span class="apidocSignatureSpan">(delay, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeatedly = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "repeatedly", [delay, values]), Bacon.fromPoll(delay, function () {
    return values[index++ % values.length];
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.sequentially(interval, values)`](#bacon-sequentially "Bacon.sequentially(interval : Number, values : Array[A]) : EventStream
[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">repeatedly</span>(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval
 : Number, values : Array[A]) : EventStream[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

&lt;a name="bacon-repeat"&gt;&lt;/a&gt;
[`Bacon.repeat(fn)`](#bacon-repeat "Bacon.repeat(fn: Number -&gt; Observable[A]): EventStream[A]") Calls generator function
 which is expected to return an observable. The returned EventStream contains
values and errors from the spawned observable. When the spawned observable ends, the generator is called
again to spawn a new observable.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.retry" id="apidoc.element.baconjs.Bacon.retry">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>retry
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (options) {
  if (!_.isFunction(options.source)) {
    throw new Exception("'source' option has to be a function");
  }
  var source = options.source;
  var retries = options.retries || 0;
  var retriesDone = 0;
  var delay = options.delay || function () {
    return 0;
  };
  var isRetryable = options.isRetryable || function () {
    return true;
  };
  var finished = false;
  var error = null;

  return withDesc(new Bacon.Desc(Bacon, "retry", [options]), Bacon.repeat(function (count) {
    function valueStream() {
      return source(count).endOnError().withHandler(function (event) {
        if (event.isError()) {
          error = event;
          if (!(isRetryable(error.error) &amp;&amp; (retries === 0 || retriesDone &lt; retries))) {
            finished = true;
            return this.push(event);
          }
        } else {
          if (event.hasValue()) {
            error = null;
            finished = true;
          }
          return this.push(event);
        }
      });
    }

    if (finished) {
      return null;
    } else if (error) {
      var context = {
        error: error.error,
        retriesDone: retriesDone
      };
      var pause = Bacon.later(delay(context)).filter(false);
      retriesDone++;
      return pause.concat(Bacon.once().flatMap(valueStream));
    } else {
      return valueStream();
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Bacon.js doesn't currently generate any [`Error`](#bacon-error) events itself (except when
converting errors using Bacon.fromPromise). Error
events definitely would be generated by streams derived from IO sources
such as AJAX calls.

&lt;a name="bacon-retry"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">retry</span>(options)`](#bacon-retry "Bacon.retry(options)") is used to retry
 the call when there is an [`Error`](#bacon-error) event in the stream produced by the `source` function.

The two required option parameters are:

* `source`, a function that produces an Observable. The function gets attempt number (starting from zero) as its argument.
* `retries`, the number of times to retry the `source` function _in addition to the initial attempt_. Use the value o (zero) for
 retrying indefinitely.

Additionally, one may pass in one or both of the following callbacks:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.sequentially" id="apidoc.element.baconjs.Bacon.sequentially">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>sequentially
        <span class="apidocSignatureSpan">(delay, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequentially = function (delay, values) {
  var index = 0;
  return withDesc(new Bacon.Desc(Bacon, "sequentially", [delay, values]), Bacon.fromPoll(delay, function () {
    var value = values[index++];
    if (index &lt; values.length) {
      return value;
    } else if (index === values.length) {
      return [value, endEvent()];
    } else {
      return endEvent();
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Bacon.fromArray([1, new Bacon.Error()])

&lt;a name="bacon-interval"&gt;&lt;/a&gt;
[`Bacon.interval(interval, value)`](#bacon-interval "Bacon.interval(interval : Number, value : A) : EventStream[A]") repeats
 the single element
indefinitely with the given interval (in milliseconds)

&lt;a name="bacon-sequentially"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">sequentially</span>(interval, values)`](#bacon-sequentially "Bacon.sequentially
(interval : Number, values : Array[A]) : EventStream[A]") creates a stream containing given
values (given as array). Delivered with given interval in milliseconds.

&lt;a name="bacon-repeatedly"&gt;&lt;/a&gt;
[`Bacon.repeatedly(interval, values)`](#bacon-repeatedly "Bacon.repeatedly(interval : Number, values : Array[A]) : EventStream
[A]") repeats given elements indefinitely
with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
would lead to `1,2,3,1,2,3...` to be repeated indefinitely.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.spy" id="apidoc.element.baconjs.Bacon.spy">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>spy
        <span class="apidocSignatureSpan">(spy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spy = function (spy) {
  return spies.push(spy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example, for `Bacon.fromArray([1,2,3]).desc` you'd get

    { context: Bacon, method: "fromArray", args: [[1,2,3]] }

Notice that this is a field, not a function.

&lt;a name="bacon-spy"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">spy</span>(f)`](#bacon-spy "Bacon.spy(f)")
Adds your function as a "spy" that will get notified on all new Observables.
This will allow a visualization/analytis tool to spy on all Bacon activity.

Cleaning up
-----------

As described above, a subscriber can signal the loss of interest in new events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.toString" id="apidoc.element.baconjs.Bacon.toString">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return "Bacon";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.try" id="apidoc.element.baconjs.Bacon.try">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>try
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">try = function (f) {
  return function (value) {
    try {
      return Bacon.once(f(value));
    } catch (e) {
      return new Bacon.Error(e);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Note also that Bacon.js combinators do not catch errors that are thrown.
Especially [`map`](#observable-map) doesn't do so. If you want to map things
and wrap caught errors into Error events, you can do the following:

```js
wrapped = source.flatMap(Bacon.<span class="apidocCodeKeywordSpan">try</span>(dangerousOperation))
```

For example, you can use `Bacon.try` to handle JSON parse errors:

```js
var jsonStream = Bacon
.once('{"this is invalid json"')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.update" id="apidoc.element.baconjs.Bacon.update">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>update
        <span class="apidocSignatureSpan">(initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (initial) {
  function lateBindFirst(f) {
    return function () {
      for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 &lt; _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }

      return function (i) {
        return f.apply(undefined, [i].concat(args));
      };
    };
  }

  for (var _len21 = arguments.length, patterns = Array(_len21 &gt; 1 ? _len21 - 1 : 0), _key21 = 1; _key21 &lt; _len21; _key21++) {
    patterns[_key21 - 1] = arguments[_key21];
  }

  var i = patterns.length - 1;
  while (i &gt; 0) {
    if (!(patterns[i] instanceof Function)) {
      patterns[i] = _.always(patterns[i]);
    }
    patterns[i] = lateBindFirst(patterns[i]);
    i = i - 2;
  }
  return withDesc(new Bacon.Desc(Bacon, "update", [initial].concat(patterns)), Bacon.when.apply(Bacon, patterns).scan(initial, function
 (x, f) {
    return f(x);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
convert it into an EventStream using [`property.changes()`](#property-changes) or [`property.toEventStream()`](#property-toeventstream
)

&lt;a name="bacon-update"&gt;&lt;/a&gt;
[`Bacon.update`](#bacon-update "Bacon.update") creates a Property from an initial value and updates the value based on
 multiple inputs.
The inputs are defined similarly to [`Bacon.when`](#bacon-when), like this:

```js
var result = Bacon.<span class="apidocCodeKeywordSpan">update</span>(
  initial,
  [x,y,z], function(previous,x,y,z) { ... },
  [x,y],   function(previous,x,y) { ... })
```

As input, each function above will get the previous value of the `result` Property, along with values from the listed Observables
.
The value returned by the function will be used as the next value of `result`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.when" id="apidoc.element.baconjs.Bacon.when">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>when
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function () {
  if (arguments.length === 0) {
    return Bacon.never();
  }
  var len = arguments.length;
  var usage = "when: expecting arguments in the form (Observable+,function)+";

  assert(usage, len % 2 === 0);
  var sources = [];
  var pats = [];
  var i = 0;
  var patterns = [];
  while (i &lt; len) {
    patterns[i] = arguments[i];
    patterns[i + 1] = arguments[i + 1];
    var patSources = _.toArray(arguments[i]);
    var f = constantToFunction(arguments[i + 1]);
    var pat = { f: f, ixs: [] };
    var triggerFound = false;
    for (var j = 0, s; j &lt; patSources.length; j++) {
      s = patSources[j];
      var index = _.indexOf(sources, s);
      if (!triggerFound) {
        triggerFound = Source.isTrigger(s);
      }
      if (index &lt; 0) {
        sources.push(s);
        index = sources.length - 1;
      }
      for (var k = 0, ix; k &lt; pat.ixs.length; k++) {
        ix = pat.ixs[k];
        if (ix.index === index) {
          ix.count++;
        }
      }
      pat.ixs.push({ index: index, count: 1 });
    }

    assert("At least one EventStream required", triggerFound || !patSources.length);

    if (patSources.length &gt; 0) {
      pats.push(pat);
    }
    i = i + 2;
  }

  if (!sources.length) {
    return Bacon.never();
  }

  sources = _.map(Source.fromObservable, sources);
  var needsBarrier = _.any(sources, function (s) {
    return s.flatten;
  }) &amp;&amp; containsDuplicateDeps(_.map(function (s) {
    return s.obs;
  }, sources));

  var desc = new Bacon.Desc(Bacon, "when", patterns);
  var resultStream = new EventStream(desc, function (sink) {
    var triggers = [];
    var ends = false;
    var match = function (p) {
      for (var i1 = 0, i; i1 &lt; p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].hasAtLeast(i.count)) {
          return false;
        }
      }
      return true;
    };
    var cannotSync = function (source) {
      return !source.sync || source.ended;
    };
    var cannotMatch = function (p) {
      for (var i1 = 0, i; i1 &lt; p.ixs.length; i1++) {
        i = p.ixs[i1];
        if (!sources[i.index].mayHave(i.count)) {
          return true;
        }
      }
    };
    var nonFlattened = function (trigger) {
      return !trigger.source.flatten;
    };
    var part = function (source) {
      return function (unsubAll) {
        var flushLater = function () {
          return UpdateBarrier.whenDoneWith(resultStream, flush);
        };
        var flushWhileTriggers = function () {
          if (triggers.length &gt; 0) {
            var reply = Bacon.more;
            var trigger = triggers.pop();
            for (var i1 = 0, p; i1 &lt; pats.length; i1++) {
              p = pats[i1];
              if (match(p)) {
                var events = (function () {
                  var result = [];
                  for (var i2 = 0, i; i2 &lt; p.ixs.length; i2++) {
                    i = p.ixs[i2];
                    result.push(sources[i.index].consume());
                  }
                  return result;
                })();
                reply = sink(trigger.e.apply(function () {
                  var _p;

                  var values = (function () {
                    var result = [];
                    for (var i2 = 0, event; i2 &lt; events.length; i2++) {
                      event = events[i2];
                      result.push(event.value());
                    }
                    return result;
                  })();

                  return (_p = p).f.apply(_p, values);
                }));
                if (triggers.length) {
                  triggers = _.filter(nonFlattened, triggers);
                }
                if (reply === Bacon.noMore) {
                  return reply;
                } else {
                  return flushWhileTriggers();
                }
              }
            }
          } else {
            return Bacon.more;
          }
        };
        var flush = function () {
          var reply = flushWhileTriggers();
          if (ends) {
            if (_.all(sources, cannotSync) || _.all(pats, cannotMatch)) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="bacon-when"&gt;&lt;/a&gt;
[`Bacon.when`](#bacon-when "Bacon.when") Consider implementing a game with discrete time ticks. We want to
handle key-events synchronized on tick-events, with at most one key
event handled per tick. If there are no key events, we want to just
process a tick.

```js
  Bacon.<span class="apidocCodeKeywordSpan">when</span>(
    [tick, keyEvent], function(_, k) { handleKeyEvent(k); return handleTick(); },
    [tick], handleTick)
```

Order is important here. If the [tick] patterns had been written
first, this would have been tried first, and preferred at each tick.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.zipAsArray" id="apidoc.element.baconjs.Bacon.zipAsArray">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>zipAsArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipAsArray = function () {
  for (var _len23 = arguments.length, args = Array(_len23), _key23 = 0; _key23 &lt; _len23; _key23++) {
    args[_key23] = arguments[_key23];
  }

  var streams = argumentsToObservables(args);
  return withDesc(new Bacon.Desc(Bacon, "zipAsArray", streams), Bacon.zipWith(streams, function () {
    for (var _len24 = arguments.length, xs = Array(_len24), _key24 = 0; _key24 &lt; _len24; _key24++) {
      xs[_key24] = arguments[_key24];
    }

    return xs;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

&lt;a name="bacon-mergeall"&gt;&lt;/a&gt;
[`Bacon.mergeAll(streams)`](#bacon-mergeall "Bacon.mergeAll(streams)") merges given array of EventStreams.
`Bacon.mergeAll(stream1, stream2 ...)` merges given EventStreams.

&lt;a name="bacon-zipasarray"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">zipAsArray</span>(streams)`](#bacon-zipasarray "Bacon.zipAsArray(streams)")
zips the array of EventStreams / Properties in to a new
EventStream that will have an array of values from each source as
its value. Zipping means that events from each source are combined
pairwise so that the 1st event from each source is published first, then
the 2nd event from each. The results will be published as soon as there
is a value from each source.

Be careful not to have too much "drift" between streams. If one stream
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bacon.zipWith" id="apidoc.element.baconjs.Bacon.zipWith">
        function <span class="apidocSignatureSpan">baconjs.Bacon.</span>zipWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipWith = function () {
  for (var _len25 = arguments.length, args = Array(_len25), _key25 = 0; _key25 &lt; _len25; _key25++) {
    args[_key25] = arguments[_key25];
  }

  var observablesAndFunction = argumentsToObservablesAndFunction(args);
  var streams = observablesAndFunction[0];
  var f = observablesAndFunction[1];

  streams = _.map(function (s) {
    return s.toEventStream();
  }, streams);
  return withDesc(new Bacon.Desc(Bacon, "zipWith", [f].concat(streams)), Bacon.when(streams, f));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

&lt;a name="bacon-zipasarray-multiple-streams"&gt;&lt;/a&gt;
[`Bacon.zipAsArray(stream1, stream2...)`](#bacon-zipasarray-multiple-streams "Bacon.zipAsArray(stream1, stream2...)")
just like above, but with sources
provided as a list of arguments as opposed to a single array.

&lt;a name="bacon-zipwith"&gt;&lt;/a&gt;
[`Bacon.<span class="apidocCodeKeywordSpan">zipWith</span>(streams, f)`](#bacon-zipwith "Bacon.zipWith(streams, f)") like
 [`zipAsArray`](#bacon-zipasarray) but uses the given n-ary
function to combine the n values from n sources, instead of returning them in an Array.

&lt;a name="bacon-zipwith-f-first"&gt;&lt;/a&gt;
[`Bacon.zipWith(f, streams)`](#bacon-zipwith-f-first "Bacon.zipWith(f, streams)") like [`zipAsArray`](#bacon-zipasarray
) but uses the given n-ary
function to combine the n values from n sources, instead of returning them in an Array.

&lt;a name="bacon-zipwith-f-first-varargs"&gt;&lt;/a&gt;
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Bus" id="apidoc.module.baconjs.Bus">module baconjs.Bus</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Bus.Bus" id="apidoc.element.baconjs.Bus.Bus">
        function <span class="apidocSignatureSpan">baconjs.</span>Bus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Bus() {
  if (!(this instanceof Bus)) {
    return new Bus();
  }

  this.unsubAll = _.bind(this.unsubAll, this);
  this.subscribeAll = _.bind(this.subscribeAll, this);
  this.guardedSink = _.bind(this.guardedSink, this);

  this.sink = undefined;
  this.subscriptions = [];
  this.ended = false;
  EventStream.call(this, new Bacon.Desc(Bacon, "Bus", []), this.subscribeAll);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.<span class="apidocCodeKeywordSpan">Bus</span>()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus
) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.

Bacon.fromBinder for custom streams
-----------------------------------
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Bus.prototype" id="apidoc.module.baconjs.Bus.prototype">module baconjs.Bus.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.end" id="apidoc.element.baconjs.Bus.prototype.end">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this.ended = true;
  this.unsubAll();
  if (typeof this.sink === "function") {
    return this.sink(endEvent());
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="new-bacon-bus"&gt;&lt;/a&gt;
[`new Bacon.Bus()`](#new-bacon-bus "new Bacon.Bus()") returns a new Bus.

&lt;a name="bus-push"&gt;&lt;/a&gt;
[`bus.push(x)`](#bus-push "bus.push(@ : Bus[A], x : A)") pushes the given value to the stream.

&lt;a name="bus-end"&gt;&lt;/a&gt;
[`bus.<span class="apidocCodeKeywordSpan">end</span>()`](#bus-end "bus.end(@ : Bus[A])") ends the stream. Sends an End
 event to all subscribers.
After this call, there'll be no more events to the subscribers.
Also, the [`bus.push`](#bus-push) and [`bus.plug`](#bus-plug) methods have no effect.

&lt;a name="bus-error"&gt;&lt;/a&gt;
[`bus.error(e)`](#bus-error "bus.error(@ : Bus[A], e : Error)") sends an Error with given message to all subscribers

&lt;a name="bus-plug"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.error" id="apidoc.element.baconjs.Bus.prototype.error">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (error) {
  if (typeof this.sink === "function") {
    return this.sink(new Error(error));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="bus-end"&gt;&lt;/a&gt;
[`bus.end()`](#bus-end "bus.end(@ : Bus[A])") ends the stream. Sends an End event to all subscribers.
After this call, there'll be no more events to the subscribers.
Also, the [`bus.push`](#bus-push) and [`bus.plug`](#bus-plug) methods have no effect.

&lt;a name="bus-error"&gt;&lt;/a&gt;
[`bus.<span class="apidocCodeKeywordSpan">error</span>(e)`](#bus-error "bus.error(@ : Bus[A], e : Error)") sends an Error
 with given message to all subscribers

&lt;a name="bus-plug"&gt;&lt;/a&gt;
[`bus.plug(stream)`](#bus-plug "bus.plug(@ : Bus[A], stream : EventStream[A])") plugs the given stream to the Bus. All
 events from
the given stream will be delivered to the subscribers of the Bus.
Returns a function that can be used to unplug the same stream.

The plug method practically allows you to merge in other streams after
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.guardedSink" id="apidoc.element.baconjs.Bus.prototype.guardedSink">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>guardedSink
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">guardedSink = function (input) {
  var _this8 = this;

  return function (event) {
    if (event.isEnd()) {
      _this8.unsubscribeInput(input);
      return Bacon.noMore;
    } else {
      return _this8.sink(event);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.plug" id="apidoc.element.baconjs.Bus.prototype.plug">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>plug
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plug = function (input) {
  var _this9 = this;

  assertObservable(input);
  if (this.ended) {
    return;
  }
  var sub = { input: input };
  this.subscriptions.push(sub);
  if (typeof this.sink !== "undefined") {
    this.subscribeInput(sub);
  }
  return function () {
    return _this9.unsubscribeInput(input);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
After this call, there'll be no more events to the subscribers.
Also, the [`bus.push`](#bus-push) and [`bus.plug`](#bus-plug) methods have no effect.

&lt;a name="bus-error"&gt;&lt;/a&gt;
[`bus.error(e)`](#bus-error "bus.error(@ : Bus[A], e : Error)") sends an Error with given message to all subscribers

&lt;a name="bus-plug"&gt;&lt;/a&gt;
[`bus.<span class="apidocCodeKeywordSpan">plug</span>(stream)`](#bus-plug "bus.plug(@ : Bus[A], stream : EventStream[A])"
;) plugs the given stream to the Bus. All events from
the given stream will be delivered to the subscribers of the Bus.
Returns a function that can be used to unplug the same stream.

The plug method practically allows you to merge in other streams after
the creation of the Bus. I've found Bus quite useful as an event broadcast
mechanism in the
[Worzone](https://github.com/raimohanska/worzone) game, for instance.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.push" id="apidoc.element.baconjs.Bus.prototype.push">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>push
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (value) {
  if (!this.ended &amp;&amp; typeof this.sink === "function") {
    var rootPush = !this.pushing;
    if (!rootPush) {
      if (!this.pushQueue) this.pushQueue = [];
      this.pushQueue.push(value);

      return;
    }
    this.pushing = true;
    try {
      return this.sink(nextEvent(value));
    } finally {
      if (rootPush &amp;&amp; this.pushQueue) {
        var i = 0;
        while (i &lt; this.pushQueue.length) {
          var value = this.pushQueue[i];
          this.sink(nextEvent(value));
          i++;
        }
        this.pushQueue = null;
      }
      this.pushing = false;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.withHandler(f)`](#observable-withhandler "observable.withHandler(f)") lets you do more custom event handling
: you
get all events to your function and you can output any number of events
and end the stream if you choose. For example, to send an error and end
the stream in case a value is below zero:

```js
if (event.hasValue() &amp;&amp; event.value() &lt; 0) {
  this.<span class="apidocCodeKeywordSpan">push</span>(new Bacon.Error("Value below zero"));
  return this.push(end());
} else {
  return this.push(event);
}
```

Note that it's important to return the value from `this.push` so that
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.subscribeAll" id="apidoc.element.baconjs.Bus.prototype.subscribeAll">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>subscribeAll
        <span class="apidocSignatureSpan">(newSink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeAll = function (newSink) {
  if (this.ended) {
    newSink(endEvent());
  } else {
    this.sink = newSink;
    var iterable = cloneArray(this.subscriptions);
    for (var i = 0, subscription; i &lt; iterable.length; i++) {
      subscription = iterable[i];
      this.subscribeInput(subscription);
    }
  }
  return this.unsubAll;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.subscribeInput" id="apidoc.element.baconjs.Bus.prototype.subscribeInput">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>subscribeInput
        <span class="apidocSignatureSpan">(subscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeInput = function (subscription) {
  subscription.unsub = subscription.input.dispatcher.subscribe(this.guardedSink(subscription.input));
  return subscription.unsub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.unsubAll" id="apidoc.element.baconjs.Bus.prototype.unsubAll">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>unsubAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubAll = function () {
  var iterable = this.subscriptions;
  for (var i = 0, sub; i &lt; iterable.length; i++) {
    sub = iterable[i];
    if (typeof sub.unsub === "function") {
      sub.unsub();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Bus.prototype.unsubscribeInput" id="apidoc.element.baconjs.Bus.prototype.unsubscribeInput">
        function <span class="apidocSignatureSpan">baconjs.Bus.prototype.</span>unsubscribeInput
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribeInput = function (input) {
  var iterable = this.subscriptions;
  for (var i = 0, sub; i &lt; iterable.length; i++) {
    sub = iterable[i];
    if (sub.input === input) {
      if (typeof sub.unsub === "function") {
        sub.unsub();
      }
      this.subscriptions.splice(i, 1);
      return;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.CompositeUnsubscribe" id="apidoc.module.baconjs.CompositeUnsubscribe">module baconjs.CompositeUnsubscribe</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.CompositeUnsubscribe" id="apidoc.element.baconjs.CompositeUnsubscribe.CompositeUnsubscribe">
        function <span class="apidocSignatureSpan">baconjs.</span>CompositeUnsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CompositeUnsubscribe() {
  var ss = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];

  this.unsubscribe = _.bind(this.unsubscribe, this);
  this.unsubscribed = false;
  this.subscriptions = [];
  this.starting = [];
  for (var i = 0, s; i &lt; ss.length; i++) {
    s = ss[i];
    this.add(s);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.CompositeUnsubscribe.prototype" id="apidoc.module.baconjs.CompositeUnsubscribe.prototype">module baconjs.CompositeUnsubscribe.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.add" id="apidoc.element.baconjs.CompositeUnsubscribe.prototype.add">
        function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>add
        <span class="apidocSignatureSpan">(subscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (subscription) {
  var _this2 = this;

  if (this.unsubscribed) {
    return;
  }
  var ended = false;
  var unsub = nop;
  this.starting.push(subscription);
  var unsubMe = function () {
    if (_this2.unsubscribed) {
      return;
    }
    ended = true;
    _this2.remove(unsub);
    return _.remove(subscription, _this2.starting);
  };
  unsub = subscription(this.unsubscribe, unsubMe);
  if (!(this.unsubscribed || ended)) {
    this.subscriptions.push(unsub);
  } else {
    unsub();
  }
  _.remove(subscription, this.starting);
  return unsub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.count" id="apidoc.element.baconjs.CompositeUnsubscribe.prototype.count">
        function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function () {
  if (this.unsubscribed) {
    return 0;
  }
  return this.subscriptions.length + this.starting.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.empty" id="apidoc.element.baconjs.CompositeUnsubscribe.prototype.empty">
        function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
  return this.count() === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.remove" id="apidoc.element.baconjs.CompositeUnsubscribe.prototype.remove">
        function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>remove
        <span class="apidocSignatureSpan">(unsub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (unsub) {
  if (this.unsubscribed) {
    return;
  }
  if (_.remove(unsub, this.subscriptions) !== undefined) {
    return unsub();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.CompositeUnsubscribe.prototype.unsubscribe" id="apidoc.element.baconjs.CompositeUnsubscribe.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">baconjs.CompositeUnsubscribe.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {
  if (this.unsubscribed) {
    return;
  }
  this.unsubscribed = true;
  var iterable = this.subscriptions;
  for (var i = 0; i &lt; iterable.length; i++) {
    iterable[i]();
  }
  this.subscriptions = [];
  this.starting = [];
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Desc" id="apidoc.module.baconjs.Desc">module baconjs.Desc</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Desc.Desc" id="apidoc.element.baconjs.Desc.Desc">
        function <span class="apidocSignatureSpan">baconjs.</span>Desc
        <span class="apidocSignatureSpan">(context, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Desc(context, method, args) {
  this.context = context;
  this.method = method;
  this.args = args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Desc.prototype" id="apidoc.module.baconjs.Desc.prototype">module baconjs.Desc.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Desc.prototype.deps" id="apidoc.element.baconjs.Desc.prototype.deps">
        function <span class="apidocSignatureSpan">baconjs.Desc.prototype.</span>deps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deps = function () {
  if (!this.cached) {
    this.cached = findDeps([this.context].concat(this.args));
  }
  return this.cached;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-tostring"&gt;&lt;/a&gt;
[`observable.toString`](#observable-tostring "observable.toString") Returns a textual description of the Observable. For
 instance,
`Bacon.once(1).map(function() {}))` would return "Bacon.once(1).map(function)".


&lt;a name="observable-deps"&gt;&lt;/a&gt;
[`observable.deps`](#observable-deps "observable.deps") Returns the an array of dependencies that the Observable has.
For instance, for `a.map(function() {}).<span class="apidocCodeKeywordSpan">deps</span>()`, would return `[a]`.
This method returns the "visible" dependencies only, skipping internal details.  This method is thus suitable for visualization
 tools.
Internally, many combinator functions depend on other combinators to create intermediate Observables that the result will actually
 depend on.
The [`deps`](#observable-deps) method will skip these internal dependencies.

&lt;a name="observable-internaldeps"&gt;&lt;/a&gt;
[`observable.internalDeps`](#observable-internaldeps "observable.internalDeps") Returns the true dependencies of the observable
, including the intermediate "hidden" Observables.
This method is for Bacon.js internal purposes but could be useful for debugging/analysis tools as well.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Desc.prototype.toString" id="apidoc.element.baconjs.Desc.prototype.toString">
        function <span class="apidocSignatureSpan">baconjs.Desc.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return _.toString(this.context) + "." + _.toString(this.method) + "(" + _.map(_.toString, this.args) + ")";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Dispatcher" id="apidoc.module.baconjs.Dispatcher">module baconjs.Dispatcher</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.Dispatcher" id="apidoc.element.baconjs.Dispatcher.Dispatcher">
        function <span class="apidocSignatureSpan">baconjs.</span>Dispatcher
        <span class="apidocSignatureSpan">(_subscribe, _handleEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Dispatcher(_subscribe, _handleEvent) {
  this._subscribe = _subscribe;
  this._handleEvent = _handleEvent;
  this.subscribe = _.bind(this.subscribe, this);
  this.handleEvent = _.bind(this.handleEvent, this);
  this.pushing = false;
  this.ended = false;
  this.prevError = undefined;
  this.unsubSrc = undefined;
  this.subscriptions = [];
  this.queue = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Dispatcher.prototype" id="apidoc.module.baconjs.Dispatcher.prototype">module baconjs.Dispatcher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.handleEvent" id="apidoc.element.baconjs.Dispatcher.prototype.handleEvent">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>handleEvent
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleEvent = function (event) {
  if (this._handleEvent) {
    return this._handleEvent(event);
  } else {
    return this.push(event);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.hasSubscribers" id="apidoc.element.baconjs.Dispatcher.prototype.hasSubscribers">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>hasSubscribers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasSubscribers = function () {
  return this.subscriptions.length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.push" id="apidoc.element.baconjs.Dispatcher.prototype.push">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>push
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (event) {
  if (event.isEnd()) {
    this.ended = true;
  }
  return UpdateBarrier.inTransaction(event, this, this.pushIt, [event]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.withHandler(f)`](#observable-withhandler "observable.withHandler(f)") lets you do more custom event handling
: you
get all events to your function and you can output any number of events
and end the stream if you choose. For example, to send an error and end
the stream in case a value is below zero:

```js
if (event.hasValue() &amp;&amp; event.value() &lt; 0) {
  this.<span class="apidocCodeKeywordSpan">push</span>(new Bacon.Error("Value below zero"));
  return this.push(end());
} else {
  return this.push(event);
}
```

Note that it's important to return the value from `this.push` so that
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.pushIt" id="apidoc.element.baconjs.Dispatcher.prototype.pushIt">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>pushIt
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushIt = function (event) {
  if (!this.pushing) {
    if (event === this.prevError) {
      return;
    }
    if (event.isError()) {
      this.prevError = event;
    }
    this.pushing = true;
    this.pushToSubscriptions(event);
    this.pushing = false;
    while (this.queue.length) {
      event = this.queue.shift();
      this.push(event);
    }
    if (this.hasSubscribers()) {
      return Bacon.more;
    } else {
      this.unsubscribeFromSource();
      return Bacon.noMore;
    }
  } else {
    this.queue.push(event);
    return Bacon.more;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.pushToSubscriptions" id="apidoc.element.baconjs.Dispatcher.prototype.pushToSubscriptions">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>pushToSubscriptions
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushToSubscriptions = function (event) {
  try {
    var tmp = this.subscriptions;
    var len = tmp.length;
    for (var i = 0; i &lt; len; i++) {
      var sub = tmp[i];
      var reply = sub.sink(event);
      if (reply === Bacon.noMore || event.isEnd()) {
        this.removeSub(sub);
      }
    }
    return true;
  } catch (error) {
    this.pushing = false;
    this.queue = [];
    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.removeSub" id="apidoc.element.baconjs.Dispatcher.prototype.removeSub">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>removeSub
        <span class="apidocSignatureSpan">(subscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeSub = function (subscription) {
  this.subscriptions = _.without(subscription, this.subscriptions);
  return this.subscriptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.subscribe" id="apidoc.element.baconjs.Dispatcher.prototype.subscribe">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (sink) {
  var subscription;
  if (this.ended) {
    sink(endEvent());
    return nop;
  } else {
    assertFunction(sink);
    subscription = {
      sink: sink
    };
    this.subscriptions.push(subscription);
    if (this.subscriptions.length === 1) {
      this.unsubSrc = this._subscribe(this.handleEvent);
      assertFunction(this.unsubSrc);
    }
    return (function (_this) {
      return function () {
        _this.removeSub(subscription);
        if (!_this.hasSubscribers()) {
          return _this.unsubscribeFromSource();
        }
      };
    })(this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
---------------------------------------------

Both EventStream and Property share the Observable interface, and hence share a lot of methods.
Methods typically return observables so that methods can be chained; exceptions are noted.
Common methods are listed below.

&lt;a name="observable-subscribe"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">subscribe</span>(f)`](#observable-subscribe "observable.subscribe(f)")
subscribes given handler function to event stream. Function will receive Event objects (see below).
The subscribe() call returns a `unsubscribe` function that you can call to unsubscribe.
You can also unsubscribe by returning [`Bacon.noMore`](#bacon-nomore) from the handler function as a reply
to an Event.
`stream.subscribe` and `property.subscribe` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

&lt;a name="observable-onvalue"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Dispatcher.prototype.unsubscribeFromSource" id="apidoc.element.baconjs.Dispatcher.prototype.unsubscribeFromSource">
        function <span class="apidocSignatureSpan">baconjs.Dispatcher.prototype.</span>unsubscribeFromSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribeFromSource = function () {
  if (this.unsubSrc) {
    this.unsubSrc();
  }
  this.unsubSrc = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.End" id="apidoc.module.baconjs.End">module baconjs.End</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.End.End" id="apidoc.element.baconjs.End.End">
        function <span class="apidocSignatureSpan">baconjs.</span>End
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function End() {
  if (!(this instanceof End)) {
    return new End();
  }
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.Next(value), new Bacon.<span class="apidocCodeKeywordSpan">End</span>()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.End.prototype" id="apidoc.module.baconjs.End.prototype">module baconjs.End.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.End.prototype.apply" id="apidoc.element.baconjs.End.prototype.apply">
        function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.End.prototype.fmap" id="apidoc.element.baconjs.End.prototype.fmap">
        function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>fmap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fmap = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.End.prototype.isEnd" id="apidoc.element.baconjs.End.prototype.isEnd">
        function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>isEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnd = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.hasValue())
      return [sum + event.value(), []]
    else if (event.<span class="apidocCodeKeywordSpan">isEnd</span>())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```

&lt;a name="observable-decode"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.End.prototype.toString" id="apidoc.element.baconjs.End.prototype.toString">
        function <span class="apidocSignatureSpan">baconjs.End.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return "&lt;end&gt;";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Error" id="apidoc.module.baconjs.Error">module baconjs.Error</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Error.Error" id="apidoc.element.baconjs.Error.Error">
        function <span class="apidocSignatureSpan">baconjs.</span>Error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error(error) {
  if (!(this instanceof Error)) {
    return new Error(error);
  }
  this.error = error;
  Event.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
when there are subscribers to the stream. Polling ends permanently when
`f` returns [`Bacon.End`](#bacon-end).

&lt;a name="bacon-once"&gt;&lt;/a&gt;
[`Bacon.once(value)`](#bacon-once "Bacon.once(value : Event[A] | A) : EventStream[A]") creates an EventStream that delivers
 the given
single value for the first subscriber. The stream will end immediately
after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
value: `Bacon.once(new Bacon.<span class="apidocCodeKeywordSpan">Error</span>("fail"))`.

&lt;a name="bacon-fromarray"&gt;&lt;/a&gt;
[`Bacon.fromArray(values)`](#bacon-fromarray "Bacon.fromArray(values : Array[Event[A] | A]) : EventStream[A]") creates
 an EventStream that delivers the given
series of values (given as array) to the first subscriber. The stream ends after these
values have been delivered. You can also send [`Bacon.Error`](#bacon-error) events, or
any combination of pure values and error events like this:
`Bacon.fromArray([1, new Bacon.Error()])
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Error.prototype" id="apidoc.module.baconjs.Error.prototype">module baconjs.Error.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Error.prototype.apply" id="apidoc.element.baconjs.Error.prototype.apply">
        function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Error.prototype.fmap" id="apidoc.element.baconjs.Error.prototype.fmap">
        function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>fmap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fmap = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Error.prototype.isError" id="apidoc.element.baconjs.Error.prototype.isError">
        function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>isError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isError = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.isNext()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.isInitial()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool") true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isError</span>()`](#event-iserror "event.isError()") true for Error events

&lt;a name="event-isend"&gt;&lt;/a&gt;
[`event.isEnd()`](#event-isend "event.isEnd()") true for End events

&lt;a name="event-error"&gt;&lt;/a&gt;
[`event.error`](#event-error "event.error") the error value of Error events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Error.prototype.toString" id="apidoc.element.baconjs.Error.prototype.toString">
        function <span class="apidocSignatureSpan">baconjs.Error.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return "&lt;error&gt; " + _.toString(this.error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Event" id="apidoc.module.baconjs.Event">module baconjs.Event</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Event.Event" id="apidoc.element.baconjs.Event.Event">
        function <span class="apidocSignatureSpan">baconjs.</span>Event
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Event() {
  this.id = ++eventIdCounter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Event.prototype" id="apidoc.module.baconjs.Event.prototype">module baconjs.Event.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.filter" id="apidoc.element.baconjs.Event.prototype.filter">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>filter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

&lt;a name="observable-filter"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">filter</span>(f)`](#observable-filter "observable.filter(@ : Observable[A],
f : A -&gt; Bool) : Observable[A]") filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
property extractor string (like ".isValuable") instead. Just like with
[`map`](#observable-map), indeed.

&lt;a name="observable-filter-property"&gt;&lt;/a&gt;
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the
 value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true
`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.hasValue" id="apidoc.element.baconjs.Event.prototype.hasValue">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>hasValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasValue = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
returns an array containing the next state and an array of output
events. Here's an example where we calculate the total sum of all
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.<span class="apidocCodeKeywordSpan">hasValue</span>())
      return [sum + event.value(), []]
    else if (event.isEnd())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.inspect" id="apidoc.element.baconjs.Event.prototype.inspect">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.isEnd" id="apidoc.element.baconjs.Event.prototype.isEnd">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnd = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.hasValue())
      return [sum + event.value(), []]
    else if (event.<span class="apidocCodeKeywordSpan">isEnd</span>())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```

&lt;a name="observable-decode"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.isError" id="apidoc.element.baconjs.Event.prototype.isError">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isError = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.isNext()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.isInitial()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool") true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isError</span>()`](#event-iserror "event.isError()") true for Error events

&lt;a name="event-isend"&gt;&lt;/a&gt;
[`event.isEnd()`](#event-isend "event.isEnd()") true for End events

&lt;a name="event-error"&gt;&lt;/a&gt;
[`event.error`](#event-error "event.error") the error value of Error events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.isEvent" id="apidoc.element.baconjs.Event.prototype.isEvent">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isEvent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEvent = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.isInitial" id="apidoc.element.baconjs.Event.prototype.isInitial">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isInitial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInitial = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-hasvalue"&gt;&lt;/a&gt;
[`event.hasValue()`](#event-hasvalue "event.hasValue(@ : Event[A]) : Bool") returns true for events of type Initial and
 Next

&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.isNext()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isInitial</span>()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool"
;) true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.isError()`](#event-iserror "event.isError()") true for Error events

&lt;a name="event-isend"&gt;&lt;/a&gt;
[`event.isEnd()`](#event-isend "event.isEnd()") true for End events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.isNext" id="apidoc.element.baconjs.Event.prototype.isNext">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>isNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNext = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-value"&gt;&lt;/a&gt;
[`event.value()`](#event-value "event.value(@ : Event[A]) : A") returns the value associated with a Next or Initial event

&lt;a name="event-hasvalue"&gt;&lt;/a&gt;
[`event.hasValue()`](#event-hasvalue "event.hasValue(@ : Event[A]) : Bool") returns true for events of type Initial and
 Next

&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isNext</span>()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true
for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.isInitial()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool") true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.isError()`](#event-iserror "event.isError()") true for Error events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Event.prototype.log" id="apidoc.element.baconjs.Event.prototype.log">
        function <span class="apidocSignatureSpan">baconjs.Event.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.constant('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').<span class="apidocCodeKeywordSpan">log</span>();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

&lt;a name="bacon-fromnodecallback"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback(f : (E -&gt; A -&gt; void) -&amp;#
x3e; void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#bacon-fromcallback),
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.EventStream" id="apidoc.module.baconjs.EventStream">module baconjs.EventStream</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.EventStream.EventStream" id="apidoc.element.baconjs.EventStream.EventStream">
        function <span class="apidocSignatureSpan">baconjs.</span>EventStream
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventStream(desc, subscribe, handler) {
  if (!(this instanceof EventStream)) {
    return new EventStream(desc, subscribe, handler);
  }
  if (_.isFunction(desc)) {
    handler = subscribe;
    subscribe = desc;
    desc = Desc.empty;
  }
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new Dispatcher(subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`Bacon.never()`](#bacon-never "Bacon.never() : EventStream") creates an EventStream that immediately ends.

&lt;a name="bacon-later"&gt;&lt;/a&gt;
[`Bacon.later(delay, value)`](#bacon-later "Bacon.later(delay : Number, value : A) : EventStream[A]") creates a single
-element stream that
produces given value after given delay (milliseconds).

&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.<span class="apidocCodeKeywordSpan">EventStream</span>(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream
(subscribe)") creates an [`EventStream`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.toEventStream()`](#property-toeventstream "property.toEventStream(@ : Property[A]) : EventStream[A]") creates
 an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.EventStream.prototype" id="apidoc.module.baconjs.EventStream.prototype">module baconjs.EventStream.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.buffer" id="apidoc.element.baconjs.EventStream.prototype.buffer">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>buffer
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer = function (delay) {
  var onInput = arguments.length &lt;= 1 || arguments[1] === undefined ? nop : arguments[1];
  var onFlush = arguments.length &lt;= 2 || arguments[2] === undefined ? nop : arguments[2];

  var buffer = {
    scheduled: null,
    end: undefined,
    values: [],
    flush: function () {
      if (this.scheduled) {
        Bacon.scheduler.clearTimeout(this.scheduled);
        this.scheduled = null;
      }
      if (this.values.length &gt; 0) {
        var valuesToPush = this.values;
        this.values = [];
        var reply = this.push(nextEvent(valuesToPush));
        if (this.end != null) {
          return this.push(this.end);
        } else if (reply !== Bacon.noMore) {
          return onFlush(this);
        }
      } else {
        if (this.end != null) {
          return this.push(this.end);
        }
      }
    },
    schedule: function () {
      var _this6 = this;

      if (!this.scheduled) {
        return this.scheduled = delay(function () {
          return _this6.flush();
        });
      }
    }
  };
  var reply = Bacon.more;
  if (!_.isFunction(delay)) {
    var delayMs = delay;
    delay = function (f) {
      return Bacon.scheduler.setTimeout(f, delayMs);
    };
  }
  return withDesc(new Bacon.Desc(this, "buffer", []), this.withHandler(function (event) {
    var _this7 = this;

    buffer.push = function (event) {
      return _this7.push(event);
    };
    if (event.isError()) {
      reply = this.push(event);
    } else if (event.isEnd()) {
      buffer.end = event;
      if (!buffer.scheduled) {
        buffer.flush();
      }
    } else {
      buffer.values.push(event.value());

      onInput(buffer);
    }
    return reply;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.bufferWithCount" id="apidoc.element.baconjs.EventStream.prototype.bufferWithCount">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithCount
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithCount = function (count) {
  return withDesc(new Bacon.Desc(this, "bufferWithCount", [count]), this.bufferWithTimeOrCount(undefined, count));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
stream.bufferWithTime(10):

```js
stream.bufferWithTime(function(f) { setTimeout(f, 10) })
```

&lt;a name="stream-bufferwithcount"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">bufferWithCount</span>(count)`](#stream-bufferwithcount "stream.bufferWithCount
(count)") buffers stream events with given count.
The buffer is flushed when it contains the given number of elements. So, if
you buffer a stream of `[1, 2, 3, 4, 5]` with count `2`, you'll get output
events with values `[1, 2]`, `[3, 4]` and `[5]`.

&lt;a name="stream-bufferwithtimeorcount"&gt;&lt;/a&gt;
[`stream.bufferWithTimeOrCount(delay, count)`](#stream-bufferwithtimeorcount "stream.bufferWithTimeOrCount(delay, count)"
;) buffers stream events and
flushes when either the buffer contains the given number elements or the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.bufferWithTime" id="apidoc.element.baconjs.EventStream.prototype.bufferWithTime">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithTime
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithTime = function (delay) {
  return withDesc(new Bacon.Desc(this, "bufferWithTime", [delay]), this.bufferWithTimeOrCount(delay, Number.MAX_VALUE));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="stream-skipuntil"&gt;&lt;/a&gt;
[`stream.skipUntil(stream2)`](#stream-skipuntil "stream.skipUntil(stream2)") skips elements from `stream` until a Next
 event
appears in `stream2`. In other words, starts delivering values
from `stream` after first event appears in `stream2`.

&lt;a name="stream-bufferwithtime"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">bufferWithTime</span>(delay)`](#stream-bufferwithtime "stream.bufferWithTime(delay
)") buffers stream events with given delay.
The buffer is flushed at most once in the given delay. So, if your input
contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]
and [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.

&lt;a name="stream-bufferwithtime-f"&gt;&lt;/a&gt;
[`stream.bufferWithTime(f)`](#stream-bufferwithtime-f "stream.bufferWithTime(f)") works with a given "defer-function
" instead
of a delay. Here's a simple example, which is equivalent to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.bufferWithTimeOrCount" id="apidoc.element.baconjs.EventStream.prototype.bufferWithTimeOrCount">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>bufferWithTimeOrCount
        <span class="apidocSignatureSpan">(delay, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferWithTimeOrCount = function (delay, count) {
  var flushOrSchedule = function (buffer) {
    if (buffer.values.length === count) {
      return buffer.flush();
    } else if (delay !== undefined) {
      return buffer.schedule();
    }
  };
  var desc = new Bacon.Desc(this, "bufferWithTimeOrCount", [delay, count]);
  return withDesc(desc, this.buffer(delay, flushOrSchedule, flushOrSchedule));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="stream-bufferwithcount"&gt;&lt;/a&gt;
[`stream.bufferWithCount(count)`](#stream-bufferwithcount "stream.bufferWithCount(count)") buffers stream events with
given count.
The buffer is flushed when it contains the given number of elements. So, if
you buffer a stream of `[1, 2, 3, 4, 5]` with count `2`, you'll get output
events with values `[1, 2]`, `[3, 4]` and `[5]`.

&lt;a name="stream-bufferwithtimeorcount"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">bufferWithTimeOrCount</span>(delay, count)`](#stream-bufferwithtimeorcount "stream
.bufferWithTimeOrCount(delay, count)") buffers stream events and
flushes when either the buffer contains the given number elements or the
given amount of milliseconds has passed since last buffered event.

&lt;a name="stream-toproperty"&gt;&lt;/a&gt;
[`stream.toProperty()`](#stream-toproperty "stream.toProperty(@ : EventStream[A]) : Property[A]") creates a Property based
 on the
EventStream. Without arguments, you'll get a Property without an initial value.
The Property will get its first actual value from the stream, and after that it'll
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.concat" id="apidoc.element.baconjs.EventStream.prototype.concat">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>concat
        <span class="apidocSignatureSpan">(right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (right) {
  var left = this;
  return new EventStream(new Bacon.Desc(left, "concat", [right]), function (sink) {
    var unsubRight = nop;
    var unsubLeft = left.dispatcher.subscribe(function (e) {
      if (e.isEnd()) {
        unsubRight = right.dispatcher.subscribe(sink);
        return unsubRight;
      } else {
        return sink(e);
      }
    });
    return function () {
      return (unsubLeft(), unsubRight());
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
EventStream
-----------

&lt;a name="bacon-eventstream"&gt;&lt;/a&gt;
[`Bacon.EventStream`](#bacon-eventstream "Bacon.EventStream") a stream of events. See methods below.

&lt;a name="stream-concat"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">concat</span>(otherStream)`](#stream-concat "stream.concat(otherStream)")
concatenates two streams into one stream so that
it will deliver events from `stream` until it ends and then deliver
events from `otherStream`. This means too that events from `stream2`,
occurring before the end of `stream` will not be included in the result
stream.

&lt;a name="stream-merge"&gt;&lt;/a&gt;
[`stream.merge(otherStream)`](#stream-merge "stream.merge(otherStream)") merges two streams into one stream that delivers
 events from both
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.delayChanges" id="apidoc.element.baconjs.EventStream.prototype.delayChanges">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>delayChanges
        <span class="apidocSignatureSpan">(desc, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayChanges = function (desc, f) {
  return withDesc(desc, f(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.flatScan" id="apidoc.element.baconjs.EventStream.prototype.flatScan">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>flatScan
        <span class="apidocSignatureSpan">(seed, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatScan = function (seed, f) {
  var current = seed;
  return this.flatMapConcat(function (next) {
    return makeObservable(f(current, next)).doAction(function (updated) {
      return current = updated;
    });
  }).toProperty(seed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="stream-toproperty-initialValue"&gt;&lt;/a&gt;
[`stream.toProperty(initialValue)`](#stream-toproperty-initialValue "stream.toProperty(initialValue)") creates a Property
 based on the
EventStream with the given initial value that will be used as the current value until
the first value comes from the stream.

&lt;a name="stream-flatscan"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">flatScan</span>(seed, f)`](#stream-flatscan "stream.flatScan(seed, f) : Property
[A]") scans stream with given seed value and accumulator function, resulting to a Property.
Difference to [`scan`](#observable-scan) is that the function `f` can return an [`EventStream`](#eventstream) or a [`Property`](#
property) instead
of a pure value, meaning that you can use [`flatScan`](#stream-flatscan) for asynchronous updates of state. It serializes
updates so that that the next update will be queued until the previous one has completed.

Property
--------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.holdWhen" id="apidoc.element.baconjs.EventStream.prototype.holdWhen">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>holdWhen
        <span class="apidocSignatureSpan">(valve)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">holdWhen = function (valve) {
  var onHold = false;
  var bufferedValues = [];
  var src = this;
  var srcIsEnded = false;
  return new EventStream(new Bacon.Desc(this, "holdWhen", [valve]), function (sink) {
    var composite = new CompositeUnsubscribe();
    var subscribed = false;
    var endIfBothEnded = function (unsub) {
      if (typeof unsub === "function") {
        unsub();
      }
      if (composite.empty() &amp;&amp; subscribed) {
        return sink(endEvent());
      }
    };
    composite.add(function (unsubAll, unsubMe) {
      return valve.subscribeInternal(function (event) {
        if (event.hasValue()) {
          onHold = event.value();
          if (!onHold) {
            var toSend = bufferedValues;
            bufferedValues = [];
            return (function () {
              var result = [];
              for (var i = 0, value; i &lt; toSend.length; i++) {
                value = toSend[i];
                result.push(sink(nextEvent(value)));
              }
              if (srcIsEnded) {
                result.push(sink(endEvent()));
                unsubMe();
              }
              return result;
            })();
          }
        } else if (event.isEnd()) {
          return endIfBothEnded(unsubMe);
        } else {
          return sink(event);
        }
      });
    });
    composite.add(function (unsubAll, unsubMe) {
      return src.subscribeInternal(function (event) {
        if (onHold &amp;&amp; event.hasValue()) {
          return bufferedValues.push(event.value());
        } else if (event.isEnd() &amp;&amp; bufferedValues.length) {
          srcIsEnded = true;
          return endIfBothEnded(unsubMe);
        } else {
          return sink(event);
        }
      });
    });
    subscribed = true;
    endIfBothEnded();
    return composite.unsubscribe;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
occurring before the end of `stream` will not be included in the result
stream.

&lt;a name="stream-merge"&gt;&lt;/a&gt;
[`stream.merge(otherStream)`](#stream-merge "stream.merge(otherStream)") merges two streams into one stream that delivers
 events from both

&lt;a name="stream-holdwhen"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">holdWhen</span>(valve)`](#stream-holdwhen "stream.holdWhen(@ : EventStream[A],
valve : Observable[B]) : EventStream[A]") pauses and buffers the event stream if last event in valve is truthy.
All buffered events are released when valve becomes falsy.

&lt;a name="stream-startwith"&gt;&lt;/a&gt;
[`stream.startWith(value)`](#stream-startwith "stream.startWith(value)") adds a starting value to the stream, i.e. concats
 a
single-element stream contains [`value`](#event-value) with this stream.

&lt;a name="stream-skipwhile"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.merge" id="apidoc.element.baconjs.EventStream.prototype.merge">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>merge
        <span class="apidocSignatureSpan">(right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (right) {
  assertEventStream(right);
  var left = this;
  return withDesc(new Bacon.Desc(left, "merge", [right]), Bacon.mergeAll(this, right));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
filter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),
[`filter`](#observable-filter), for example, are similar to same functions in functional list programming
(like [Underscore](http://underscorejs.org/)). So, if you say

```js
var plus = $("#plus").asEventStream("click").map(1)
var minus = $("#minus").asEventStream("click").map(-1)
var both = plus.<span class="apidocCodeKeywordSpan">merge</span>(minus)
```

.. you'll have a stream that will output the number 1 when the "plus" button is clicked
and another stream outputting -1 when the "minus" button is clicked. The `both` stream will
be a merged stream containing events from both the plus and minus streams. This allows
you to subscribe to both streams with one handler:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.sampledBy" id="apidoc.element.baconjs.EventStream.prototype.sampledBy">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>sampledBy
        <span class="apidocSignatureSpan">(sampler, combinator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampledBy = function (sampler, combinator) {
  return withDesc(new Bacon.Desc(this, "sampledBy", [sampler, combinator]), this.toProperty().sampledBy(sampler, combinator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the input values. If keyCode was a function, the result stream would
contain the values returned by the function.
The [Function Construction rules](#function-construction-rules) below apply here.
The [`map`](#observable-map) method, among many others, uses [lazy evaluation](#lazy-evaluation).

&lt;a name="stream-map"&gt;&lt;/a&gt;
[`stream.map(property)`](#stream-map "stream.map(property)") maps the stream events to the current value of
the given property. This is equivalent to [`property.<span class="apidocCodeKeywordSpan">sampledBy</span>(stream)`](#property-sampledby
).

&lt;a name="observable-maperror"&gt;&lt;/a&gt;
[`observable.mapError(f)`](#observable-maperror "observable.mapError(@ : Observable[A], f : E -&gt; A) : Observable[A]"
;) maps errors using given function. More
specifically, feeds the "error" field of the error event to the function
and produces a [`Next`](#bacon-next) event based on the return value.
The [Function Construction rules](#function-construction-rules) below apply here.
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.skipUntil" id="apidoc.element.baconjs.EventStream.prototype.skipUntil">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>skipUntil
        <span class="apidocSignatureSpan">(starter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipUntil = function (starter) {
  var started = starter.take(1).map(true).toProperty(false);
  return withDesc(new Bacon.Desc(this, "skipUntil", [starter]), this.filter(started));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="stream-skipwhile-property"&gt;&lt;/a&gt;
[`stream.skipWhile(property)`](#stream-skipwhile-property "stream.skipWhile(property)") skips elements until the value
 of the given Property is falsy once, and then
lets all events pass through.

&lt;a name="stream-skipuntil"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">skipUntil</span>(stream2)`](#stream-skipuntil "stream.skipUntil(stream2)")
skips elements from `stream` until a Next event
appears in `stream2`. In other words, starts delivering values
from `stream` after first event appears in `stream2`.

&lt;a name="stream-bufferwithtime"&gt;&lt;/a&gt;
[`stream.bufferWithTime(delay)`](#stream-bufferwithtime "stream.bufferWithTime(delay)") buffers stream events with given
 delay.
The buffer is flushed at most once in the given delay. So, if your input
contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.skipWhile" id="apidoc.element.baconjs.EventStream.prototype.skipWhile">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (f) {
  assertObservableIsProperty(f);
  var ok = false;

  for (var _len19 = arguments.length, args = Array(_len19 &gt; 1 ? _len19 - 1 : 0), _key19 = 1; _key19 &lt; _len19; _key19++) {
    args[_key19 - 1] = arguments[_key19];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "skipWhile", [f]), this.withHandler(function (event) {
      if (ok || !event.hasValue() || !f(event.value())) {
        if (event.hasValue()) {
          ok = true;
        }
        return this.push(event);
      } else {
        return Bacon.more;
      }
    }));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
All buffered events are released when valve becomes falsy.

&lt;a name="stream-startwith"&gt;&lt;/a&gt;
[`stream.startWith(value)`](#stream-startwith "stream.startWith(value)") adds a starting value to the stream, i.e. concats
 a
single-element stream contains [`value`](#event-value) with this stream.

&lt;a name="stream-skipwhile"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">skipWhile</span>(f)`](#stream-skipwhile "stream.skipWhile(f)") skips elements
 until the given predicate function returns falsy once, and then
lets all events pass through.
The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="stream-skipwhile-property"&gt;&lt;/a&gt;
[`stream.skipWhile(property)`](#stream-skipwhile-property "stream.skipWhile(property)") skips elements until the value
 of the given Property is falsy once, and then
lets all events pass through.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.startWith" id="apidoc.element.baconjs.EventStream.prototype.startWith">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>startWith
        <span class="apidocSignatureSpan">(seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startWith = function (seed) {
  return withDesc(new Bacon.Desc(this, "startWith", [seed]), Bacon.once(seed).concat(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`stream.merge(otherStream)`](#stream-merge "stream.merge(otherStream)") merges two streams into one stream that delivers
 events from both

&lt;a name="stream-holdwhen"&gt;&lt;/a&gt;
[`stream.holdWhen(valve)`](#stream-holdwhen "stream.holdWhen(@ : EventStream[A], valve : Observable[B]) : EventStream[A]"
;) pauses and buffers the event stream if last event in valve is truthy.
All buffered events are released when valve becomes falsy.

&lt;a name="stream-startwith"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">startWith</span>(value)`](#stream-startwith "stream.startWith(value)") adds
 a starting value to the stream, i.e. concats a
single-element stream contains [`value`](#event-value) with this stream.

&lt;a name="stream-skipwhile"&gt;&lt;/a&gt;
[`stream.skipWhile(f)`](#stream-skipwhile "stream.skipWhile(f)") skips elements until the given predicate function returns
 falsy once, and then
lets all events pass through.
The [Function Construction rules](#function-construction-rules) below apply here.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.takeUntil" id="apidoc.element.baconjs.EventStream.prototype.takeUntil">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>takeUntil
        <span class="apidocSignatureSpan">(stopper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeUntil = function (stopper) {
  var endMarker = {};
  return withDesc(new Bacon.Desc(this, "takeUntil", [stopper]), Bacon.groupSimultaneous(this.mapEnd(endMarker), stopper.skipErrors
()).withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else {
      var _event$value = event.value();

      var data = _event$value[0];
      var stopper = _event$value[1];

      if (stopper.length) {
        return this.push(endEvent());
      } else {
        var reply = Bacon.more;
        for (var i = 0, value; i &lt; data.length; i++) {
          value = data[i];
          if (value === endMarker) {
            reply = this.push(endEvent());
          } else {
            reply = this.push(nextEvent(value));
          }
        }
        return reply;
      }
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-take"&gt;&lt;/a&gt;
[`observable.take(n)`](#observable-take "observable.take(@ : Observable[A], n : Number) : Observable[A]") takes at most
 n values from the stream and then ends the stream. If the stream has
fewer than n values then it is unaffected.
Equal to [`Bacon.never()`](#bacon-never) if `n &lt;= 0`.

&lt;a name="observable-takeuntil"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">takeUntil</span>(stream)`](#observable-takeuntil "observable.takeUntil(@ :
Observable[A], stream : EventStream[B]) : Observable[A]") takes elements from source until a Next event appears in the other
 stream.
If other stream ends without value, it is ignored.

&lt;a name="observable-takewhile"&gt;&lt;/a&gt;
[`observable.takeWhile(f)`](#observable-takewhile "observable.takeWhile(@ : Observable[A], f : A -&gt; Bool) : Observable
[A]") takes while given predicate function holds true, and then ends.
[Function Construction rules](#function-construction-rules) apply.

&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.toEventStream" id="apidoc.element.baconjs.EventStream.prototype.toEventStream">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>toEventStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEventStream = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">toEventStream</span>()`](#property-toeventstream "property.toEventStream(@ :
Property[A]) : EventStream[A]") creates an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.Bus()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.toProperty" id="apidoc.element.baconjs.EventStream.prototype.toProperty">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>toProperty
        <span class="apidocSignatureSpan">(initValue_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toProperty = function (initValue_) {
  var initValue = arguments.length === 0 ? None : toOption(function () {
    return initValue_;
  });
  var disp = this.dispatcher;
  var desc = new Bacon.Desc(this, "toProperty", [initValue_]);
  return new Property(desc, function (sink) {
    var initSent = false;
    var subbed = false;
    var unsub = nop;
    var reply = Bacon.more;
    var sendInit = function () {
      if (!initSent) {
        return initValue.forEach(function (value) {
          initSent = true;
          reply = sink(new Initial(value));
          if (reply === Bacon.noMore) {
            unsub();
            unsub = nop;
            return nop;
          }
        });
      }
    };

    unsub = disp.subscribe(function (event) {
      if (event.hasValue()) {
        if (event.isInitial() &amp;&amp; !subbed) {
          initValue = new Some(function () {
            return event.value();
          });
          return Bacon.more;
        } else {
          if (!event.isInitial()) {
            sendInit();
          }
          initSent = true;
          initValue = new Some(event);
          return sink(event);
        }
      } else {
        if (event.isEnd()) {
          reply = sendInit();
        }
        if (reply !== Bacon.noMore) {
          return sink(event);
        }
      }
    });
    subbed = true;
    sendInit();
    return unsub;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="stream-bufferwithtimeorcount"&gt;&lt;/a&gt;
[`stream.bufferWithTimeOrCount(delay, count)`](#stream-bufferwithtimeorcount "stream.bufferWithTimeOrCount(delay, count)"
;) buffers stream events and
flushes when either the buffer contains the given number elements or the
given amount of milliseconds has passed since last buffered event.

&lt;a name="stream-toproperty"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">toProperty</span>()`](#stream-toproperty "stream.toProperty(@ : EventStream[A]) :
Property[A]") creates a Property based on the
EventStream. Without arguments, you'll get a Property without an initial value.
The Property will get its first actual value from the stream, and after that it'll
always have a current value.

&lt;a name="stream-toproperty-initialValue"&gt;&lt;/a&gt;
[`stream.toProperty(initialValue)`](#stream-toproperty-initialValue "stream.toProperty(initialValue)") creates a Property
 based on the
EventStream with the given initial value that will be used as the current value until
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.EventStream.prototype.withHandler" id="apidoc.element.baconjs.EventStream.prototype.withHandler">
        function <span class="apidocSignatureSpan">baconjs.EventStream.prototype.</span>withHandler
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withHandler = function (handler) {
  return new EventStream(new Bacon.Desc(this, "withHandler", [handler]), this.dispatcher.subscribe, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-endonerror-f"&gt;&lt;/a&gt;
[`observable.endOnError(f)`](#observable-endonerror-f "observable.endOnError(f)") ends the `Observable` on first [`Error
`](#bacon-error) event for which
the given predicate function returns true. The error is included in the
output of the returned `Observable`. The [Function Construction rules](#function-construction-rules) apply, so
you can do for example `.endOnError(".serious")`.

&lt;a name="observable-withhandler"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">withHandler</span>(f)`](#observable-withhandler "observable.withHandler(f)&amp;#
x22;) lets you do more custom event handling: you
get all events to your function and you can output any number of events
and end the stream if you choose. For example, to send an error and end
the stream in case a value is below zero:

```js
if (event.hasValue() &amp;&amp; event.value() &lt; 0) {
this.push(new Bacon.Error("Value below zero"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Initial" id="apidoc.module.baconjs.Initial">module baconjs.Initial</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Initial.Initial" id="apidoc.element.baconjs.Initial.Initial">
        function <span class="apidocSignatureSpan">baconjs.</span>Initial
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Initial(valueF, eager) {
  if (!(this instanceof Initial)) {
    return new Initial(valueF, eager);
  }
  Next.call(this, valueF, eager);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Initial.prototype" id="apidoc.module.baconjs.Initial.prototype">module baconjs.Initial.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Initial.prototype.apply" id="apidoc.element.baconjs.Initial.prototype.apply">
        function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>apply
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (value) {
  return new Initial(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Initial.prototype.isInitial" id="apidoc.element.baconjs.Initial.prototype.isInitial">
        function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>isInitial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInitial = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-hasvalue"&gt;&lt;/a&gt;
[`event.hasValue()`](#event-hasvalue "event.hasValue(@ : Event[A]) : Bool") returns true for events of type Initial and
 Next

&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.isNext()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isInitial</span>()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool"
;) true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.isError()`](#event-iserror "event.isError()") true for Error events

&lt;a name="event-isend"&gt;&lt;/a&gt;
[`event.isEnd()`](#event-isend "event.isEnd()") true for End events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Initial.prototype.isNext" id="apidoc.element.baconjs.Initial.prototype.isNext">
        function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>isNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNext = function () {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-value"&gt;&lt;/a&gt;
[`event.value()`](#event-value "event.value(@ : Event[A]) : A") returns the value associated with a Next or Initial event

&lt;a name="event-hasvalue"&gt;&lt;/a&gt;
[`event.hasValue()`](#event-hasvalue "event.hasValue(@ : Event[A]) : Bool") returns true for events of type Initial and
 Next

&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isNext</span>()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true
for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.isInitial()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool") true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.isError()`](#event-iserror "event.isError()") true for Error events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Initial.prototype.toNext" id="apidoc.element.baconjs.Initial.prototype.toNext">
        function <span class="apidocSignatureSpan">baconjs.Initial.prototype.</span>toNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNext = function () {
  return new Next(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Next" id="apidoc.module.baconjs.Next">module baconjs.Next</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Next.Next" id="apidoc.element.baconjs.Next.Next">
        function <span class="apidocSignatureSpan">baconjs.</span>Next
        <span class="apidocSignatureSpan">(valueF, eager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Next(valueF, eager) {
  if (!(this instanceof Next)) {
    return new Next(valueF, eager);
  }

  Event.call(this);

  if (!eager &amp;&amp; _.isFunction(valueF) || (valueF != null ? valueF._isNext : void 0)) {
    this.valueF = valueF;
    this.valueInternal = void 0;
  } else {
    this.valueF = void 0;
    this.valueInternal = valueF;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$("#my-div").asEventStream("click", function(event, args) { return args[0] })
```

&lt;a name="bacon-frompromise"&gt;&lt;/a&gt;
[`Bacon.fromPromise(promise [, abort] [, eventTransformer])`](#bacon-frompromise "Bacon.fromPromise(promise : Promise[A] [,
abort : boolean][, eventTransformer]) : EventStream[A]") creates an EventStream from a Promise object such as JQuery Ajax.
This stream will contain a single value or an error, followed immediately by stream end.
You can use the optional abort flag (i.e. Â´fromPromise(p, true)Â´ to have the `abort` method of the given promise be called when
all subscribers have been removed from the created stream.
You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into
 `[new Bacon.<span class="apidocCodeKeywordSpan">Next</span>(value), new Bacon.End()]`.
Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

&lt;a name="bacon-fromevent"&gt;&lt;/a&gt;
[`Bacon.fromEvent(target, eventName [, eventTransformer])`](#bacon-fromevent "Bacon.fromEvent(target : EventTarget | EventEmitter
, eventName : String [, eventTransformer]) : EventStream") creates an EventStream from events
on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
You can also pass an optional function that transforms the emitted
events' parameters.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Next.prototype" id="apidoc.module.baconjs.Next.prototype">module baconjs.Next.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.apply" id="apidoc.element.baconjs.Next.prototype.apply">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>apply
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (value) {
  return new Next(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.filter" id="apidoc.element.baconjs.Next.prototype.filter">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>filter
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (f) {
  return f(this.value());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

&lt;a name="observable-filter"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">filter</span>(f)`](#observable-filter "observable.filter(@ : Observable[A],
f : A -&gt; Bool) : Observable[A]") filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
property extractor string (like ".isValuable") instead. Just like with
[`map`](#observable-map), indeed.

&lt;a name="observable-filter-property"&gt;&lt;/a&gt;
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the
 value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true
`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.fmap" id="apidoc.element.baconjs.Next.prototype.fmap">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>fmap
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fmap = function (f) {
  var event, value;
  if (this.valueInternal) {
    value = this.valueInternal;
    return this.apply(function () {
      return f(value);
    });
  } else {
    event = this;
    return this.apply(function () {
      return f(event.value());
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.hasValue" id="apidoc.element.baconjs.Next.prototype.hasValue">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>hasValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasValue = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
returns an array containing the next state and an array of output
events. Here's an example where we calculate the total sum of all
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.<span class="apidocCodeKeywordSpan">hasValue</span>())
      return [sum + event.value(), []]
    else if (event.isEnd())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.isNext" id="apidoc.element.baconjs.Next.prototype.isNext">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>isNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNext = function () {
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="event-value"&gt;&lt;/a&gt;
[`event.value()`](#event-value "event.value(@ : Event[A]) : A") returns the value associated with a Next or Initial event

&lt;a name="event-hasvalue"&gt;&lt;/a&gt;
[`event.hasValue()`](#event-hasvalue "event.hasValue(@ : Event[A]) : Bool") returns true for events of type Initial and
 Next

&lt;a name="event-isnext"&gt;&lt;/a&gt;
[`event.<span class="apidocCodeKeywordSpan">isNext</span>()`](#event-isnext "event.isNext(@ : Event[A]) : Bool") true
for Next events

&lt;a name="event-isinitial"&gt;&lt;/a&gt;
[`event.isInitial()`](#event-isinitial "event.isInitial(@ : Event[A]) : Bool") true for Initial events

&lt;a name="event-iserror"&gt;&lt;/a&gt;
[`event.isError()`](#event-iserror "event.isError()") true for Error events
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.log" id="apidoc.element.baconjs.Next.prototype.log">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  return this.value();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.constant('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').<span class="apidocCodeKeywordSpan">log</span>();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

&lt;a name="bacon-fromnodecallback"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback(f : (E -&gt; A -&gt; void) -&amp;#
x3e; void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#bacon-fromcallback),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.toString" id="apidoc.element.baconjs.Next.prototype.toString">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return _.toString(this.value());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Next.prototype.value" id="apidoc.element.baconjs.Next.prototype.value">
        function <span class="apidocSignatureSpan">baconjs.Next.prototype.</span>value
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function () {
  var ref;
  if ((ref = this.valueF) != null ? ref._isNext : void 0) {
    this.valueInternal = this.valueF.value();
    this.valueF = void 0;
  } else if (this.valueF) {
    this.valueInternal = this.valueF();
    this.valueF = void 0;
  }
  return this.valueInternal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
events. Here's an example where we calculate the total sum of all
numbers in the stream and output the value on stream end:

```js
Bacon.fromArray([1,2,3])
  .withStateMachine(0, function(sum, event) {
    if (event.hasValue())
      return [sum + event.<span class="apidocCodeKeywordSpan">value</span>(), []]
    else if (event.isEnd())
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Observable" id="apidoc.module.baconjs.Observable">module baconjs.Observable</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Observable.Observable" id="apidoc.element.baconjs.Observable.Observable">
        function <span class="apidocSignatureSpan">baconjs.</span>Observable
        <span class="apidocSignatureSpan">(desc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable(desc) {
  this.desc = desc;
  this.id = ++idCounter;
  this.initialDesc = this.desc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Observable.prototype" id="apidoc.module.baconjs.Observable.prototype">module baconjs.Observable.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.assign" id="apidoc.element.baconjs.Observable.prototype.assign">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>assign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assign = function () {
  var f = makeFunctionArgs(arguments);
  return this.subscribe(function (event) {
    if (event.hasValue()) {
      return f(event.value());
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
seed value and on each event in the source stream applies the accumulator function to the current
property value and the new value from the stream.

Properties can be very conveniently used for assigning values and attributes to DOM elements with JQuery.
Here we assign the value of a property as the text of a span element whenever it changes:

```js
property.<span class="apidocCodeKeywordSpan">assign</span>($("span"), "text")
```

Hiding and showing the same span depending on the content of the property value is equally straightforward

```js
function hiddenForEmptyValue(value) { return value == "" ? "hidden" : "visible" }
property.map(hiddenForEmptyValue).assign($("span"), "css", "visibility")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.awaiting" id="apidoc.element.baconjs.Observable.prototype.awaiting">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>awaiting
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaiting = function (other) {
  var desc = new Bacon.Desc(this, "awaiting", [other]);
  return withDesc(desc, Bacon.groupSimultaneous(this, other).map(function (values) {
    return values[1].length === 0;
  }).toProperty(false).skipDuplicates());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
property.decode({1 : { type: "mike" }, 2 : { type: "other", whoThen : who }})
```

The return value of [`decode`](#observable-decode) is always a [`Property`](#property).

&lt;a name="observable-awaiting"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">awaiting</span>(otherObservable)`](#observable-awaiting "observable.awaiting
(otherObservable)") creates a Property that indicates whether
`observable` is awaiting `otherObservable`, i.e. has produced a value after the latest
value from `otherObservable`. This is handy for keeping track whether we are
currently awaiting an AJAX response:

```js
var showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.bufferingThrottle" id="apidoc.element.baconjs.Observable.prototype.bufferingThrottle">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>bufferingThrottle
        <span class="apidocSignatureSpan">(minimumInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferingThrottle = function (minimumInterval) {
  var desc = new Bacon.Desc(this, "bufferingThrottle", [minimumInterval]);
  return withDesc(desc, this.flatMapConcat(function (x) {
    return Bacon.once(x).concat(Bacon.later(minimumInterval).filter(false));
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:                      asdf----asdf----
source.debounceImmediate(2): a-d-----a-d-----
```

&lt;a name="observable-bufferingthrottle"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">bufferingThrottle</span>(minimumInterval)`](#observable-bufferingthrottle "
;observable.bufferingThrottle(@ : Observable[A], minimumInterval) : EventStream[A]") throttles the observable using a buffer
 so that at most one value event in minimumInteval is issued.
Unlike [`throttle`](#observable-throttle), it doesn't discard the excessive events but buffers them instead, outputting
them with a rate of at most one value per minimumInterval.

Example:

```js
var throttled = source.bufferingThrottle(2)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.combine" id="apidoc.element.baconjs.Observable.prototype.combine">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>combine
        <span class="apidocSignatureSpan">(other, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combine = function (other, f) {
  var combinator = toCombinator(f);
  var desc = new Bacon.Desc(this, "combine", [other, f]);
  return withDesc(desc, Bacon.combineAsArray(this, other).map(function (values) {
    return combinator(values[0], values[1]);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.doLog()`](#observable-dolog "observable.doLog()") logs each value of the Observable to the console. doLog
() behaves like [`log`](#observable-log)
but does not subscribe to the event stream. You can think of doLog() as a
logger function that â€“ unlike log() â€“ is safe to use in production. doLog() is
safe, because it does not cause the same surprising side-effects as log()
does.

&lt;a name="observable-combine"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">combine</span>(property2, f)`](#observable-combine "observable.combine(property2
, f)") combines the latest values of the two
streams or properties using a two-arg function. Similarly to [`scan`](#observable-scan), you can use a
method name instead, so you could do `a.combine(b, ".concat")` for two
properties with array value. The result is a Property.

&lt;a name="observable-withstatemachine"&gt;&lt;/a&gt;
[`observable.withStateMachine(initState, f)`](#observable-withstatemachine "observable.withStateMachine(initState, f)")
lets you run a state machine
on an observable. Give it an initial state object and a state
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.debounce" id="apidoc.element.baconjs.Observable.prototype.debounce">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>debounce
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debounce = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "debounce", [delay]), function (changes) {
    return changes.flatMapLatest(function (value) {
      return Bacon.later(delay, value);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:    asdf----asdf----
throttled: --s--f----s--f--
```

&lt;a name="observable-debounce"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">debounce</span>(delay)`](#observable-debounce "observable.debounce(delay)&amp;#
x22;) throttles stream/property by given amount
of milliseconds, but so that event is only emitted after the given
"quiet period". Does not affect emitting the initial value of a Property.
The difference of [`throttle`](#observable-throttle) and [`debounce`](#observable-debounce) is the same as it is in the
same methods in jQuery.

Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.debounceImmediate" id="apidoc.element.baconjs.Observable.prototype.debounceImmediate">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>debounceImmediate
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debounceImmediate = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "debounceImmediate", [delay]), function (changes) {
    return changes.flatMapFirst(function (value) {
      return Bacon.once(value).concat(Bacon.later(delay).filter(false));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:             asdf----asdf----
source.debounce(2): -----f-------f--
```

&lt;a name="observable-debounceimmediate"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">debounceImmediate</span>(delay)`](#observable-debounceimmediate "observable
.debounceImmediate(delay)") passes the first event in the
stream through, but after that, only passes events after a given number
of milliseconds have passed since previous output.

Example:

```
source:                      asdf----asdf----
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.decode" id="apidoc.element.baconjs.Observable.prototype.decode">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>decode
        <span class="apidocSignatureSpan">(cases)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (cases) {
  return withDesc(new Bacon.Desc(this, "decode", [cases]), this.combine(Bacon.combineTemplate(cases), function (key, values) {
    return values[key];
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return [undefined, [new Bacon.Next(sum), event]]
    else
      return [sum, [event]]
  })
```

&lt;a name="observable-decode"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">decode</span>(mapping)`](#observable-decode "observable.decode(mapping)"
;) decodes input using the given mapping. Is a
bit like a switch-case or the decode function in Oracle SQL. For
example, the following would map the value 1 into the string "mike"
and the value 2 into the value of the `who` property.

```js
property.decode({1 : "mike", 2 : who})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.delay" id="apidoc.element.baconjs.Observable.prototype.delay">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>delay
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "delay", [delay]), function (changes) {
    return changes.flatMap(function (value) {
      return Bacon.later(delay, value);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

&lt;a name="observable-skip"&gt;&lt;/a&gt;
[`observable.skip(n)`](#observable-skip "observable.skip(n)") skips the first n elements from the stream

&lt;a name="observable-delay"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">delay</span>(delay)`](#observable-delay "observable.delay(delay)") delays
 the stream/property by given amount of milliseconds. Does not delay the initial value of a [`Property`](#property).

```js
var delayed = source.delay(2)
```

```
source:    asdf----asdf----
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.deps" id="apidoc.element.baconjs.Observable.prototype.deps">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>deps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deps = function () {
  return this.desc.deps();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-tostring"&gt;&lt;/a&gt;
[`observable.toString`](#observable-tostring "observable.toString") Returns a textual description of the Observable. For
 instance,
`Bacon.once(1).map(function() {}))` would return "Bacon.once(1).map(function)".


&lt;a name="observable-deps"&gt;&lt;/a&gt;
[`observable.deps`](#observable-deps "observable.deps") Returns the an array of dependencies that the Observable has.
For instance, for `a.map(function() {}).<span class="apidocCodeKeywordSpan">deps</span>()`, would return `[a]`.
This method returns the "visible" dependencies only, skipping internal details.  This method is thus suitable for visualization
 tools.
Internally, many combinator functions depend on other combinators to create intermediate Observables that the result will actually
 depend on.
The [`deps`](#observable-deps) method will skip these internal dependencies.

&lt;a name="observable-internaldeps"&gt;&lt;/a&gt;
[`observable.internalDeps`](#observable-internaldeps "observable.internalDeps") Returns the true dependencies of the observable
, including the intermediate "hidden" Observables.
This method is for Bacon.js internal purposes but could be useful for debugging/analysis tools as well.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.diff" id="apidoc.element.baconjs.Observable.prototype.diff">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>diff
        <span class="apidocSignatureSpan">(start, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (start, f) {
  f = toCombinator(f);
  return withDesc(new Bacon.Desc(this, "diff", [start, f]), this.scan([start], function (prevTuple, next) {
    return [next, f(prevTuple[0], next)];
  }).filter(function (tuple) {
    return tuple.length === 2;
  }).map(function (tuple) {
    return tuple[1];
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
value, i.e. the value just before the observable ends. Returns a
[`Property`](#property).

&lt;a name="observable-reduce"&gt;&lt;/a&gt;
[`observable.reduce(seed, f)`](#observable-reduce "observable.reduce(seed,f)") synonym for [`fold`](#observable-fold).

&lt;a name="observable-diff"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">diff</span>(start, f)`](#observable-diff "observable.diff(start, f)")
returns a Property that represents the result of a comparison
between the previous and current value of the Observable. For the initial value of the Observable,
the previous value will be the given start.

Example:

```js
var distance = function (a,b) { return Math.abs(b - a) }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.doAction" id="apidoc.element.baconjs.Observable.prototype.doAction">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doAction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doAction = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doAction", [f]), this.withHandler(function (event) {
    if (event.hasValue()) {
      f(event.value());
    }
    return this.push(event);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:    asdf----asdf----
throttled: a-s-d-f-a-s-d-f-
```

&lt;a name="observable-doaction"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">doAction</span>(f)`](#observable-doaction "observable.doAction(f)") returns
 a stream/property where the function f
is executed for each value, before dispatching to subscribers. This is
useful for debugging, but also for stuff like calling the
`preventDefault()` method for events. In fact, you can
also use a property-extractor string instead of a function, as in
`".preventDefault"`.

&lt;a name="observable-doerror"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.doEnd" id="apidoc.element.baconjs.Observable.prototype.doEnd">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doEnd = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doEnd", [f]), this.withHandler(function (event) {
    if (event.isEnd()) {
      f();
    }
    return this.push(event);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.doError" id="apidoc.element.baconjs.Observable.prototype.doError">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doError = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "doError", [f]), this.withHandler(function (event) {
    if (event.isError()) {
      f(event.error);
    }
    return this.push(event);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is executed for each value, before dispatching to subscribers. This is
useful for debugging, but also for stuff like calling the
`preventDefault()` method for events. In fact, you can
also use a property-extractor string instead of a function, as in
`".preventDefault"`.

&lt;a name="observable-doerror"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">doError</span>(f)`](#observable-doerror "observable.doError(f)") returns
 a stream/property where the function f
is executed for each error, before dispatching to subscribers.
That is, same as [`doAction`](#observable-doaction) but for errors.

&lt;a name="observable-not"&gt;&lt;/a&gt;
[`observable.not()`](#observable-not "observable.not(@ : Obserable[A]) : Observable[Bool]") returns a stream/property
that inverts boolean values

&lt;a name="observable-flatmap"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.doLog" id="apidoc.element.baconjs.Observable.prototype.doLog">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>doLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLog = function () {
  for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 &lt; _len15; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return withDesc(new Bacon.Desc(this, "doLog", args), this.withHandler(function (event) {
    if (typeof console !== "undefined" &amp;&amp; console !== null &amp;&amp; typeof console.log === "function") {
      console.log.apply(console, args.concat([event.log()]));
    }
    return this.push(event);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
or just

```js
myStream.log()
```

&lt;a name="observable-dolog"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">doLog</span>()`](#observable-dolog "observable.doLog()") logs each value
 of the Observable to the console. doLog() behaves like [`log`](#observable-log)
but does not subscribe to the event stream. You can think of doLog() as a
logger function that â€“ unlike log() â€“ is safe to use in production. doLog() is
safe, because it does not cause the same surprising side-effects as log()
does.

&lt;a name="observable-combine"&gt;&lt;/a&gt;
[`observable.combine(property2, f)`](#observable-combine "observable.combine(property2, f)") combines the latest values
 of the two
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.endOnError" id="apidoc.element.baconjs.Observable.prototype.endOnError">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>endOnError
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endOnError = function (f) {
  if (!(typeof f !== "undefined" &amp;&amp; f !== null)) {
    f = true;
  }

  for (var _len16 = arguments.length, args = Array(_len16 &gt; 1 ? _len16 - 1 : 0), _key16 = 1; _key16 &lt; _len16; _key16++) {
    args[_key16 - 1] = arguments[_key16];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "endOnError", []), this.withHandler(function (event) {
      if (event.isError() &amp;&amp; f(event.error)) {
        this.push(event);
        return this.push(endEvent());
      } else {
        return this.push(event);
      }
    }));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
currently awaiting an AJAX response:

```js
var showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)
```

&lt;a name="observable-endonerror"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">endOnError</span>()`](#observable-endonerror "observable.endOnError()"
;) ends the `Observable` on first [`Error`](#bacon-error) event. The
error is included in the output of the returned `Observable`.

&lt;a name="observable-endonerror-f"&gt;&lt;/a&gt;
[`observable.endOnError(f)`](#observable-endonerror-f "observable.endOnError(f)") ends the `Observable` on first [`Error
`](#bacon-error) event for which
the given predicate function returns true. The error is included in the
output of the returned `Observable`. The [Function Construction rules](#function-construction-rules) apply, so
you can do for example `.endOnError(".serious")`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.errors" id="apidoc.element.baconjs.Observable.prototype.errors">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>errors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function () {
  return withDesc(new Bacon.Desc(this, "errors", []), this.filter(function () {
    return false;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.mapError(f)`](#observable-maperror "observable.mapError(@ : Observable[A], f : E -&gt; A) : Observable[A]"
;) maps errors using given function. More
specifically, feeds the "error" field of the error event to the function
and produces a [`Next`](#bacon-next) event based on the return value.
The [Function Construction rules](#function-construction-rules) below apply here.
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.

&lt;a name="observable-errors"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">errors</span>()`](#observable-errors "observable.errors(@ : Observable[A]) :
Observable[A]") returns a stream containing [`Error`](#bacon-error) events only.
Same as filtering with a function that always returns false.

&lt;a name="observable-skiperrors"&gt;&lt;/a&gt;
[`observable.skipErrors()`](#observable-skiperrors "observable.skipErrors(@ : Observable[A]) : Observable[A]") skips all
 errors.

&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.filter" id="apidoc.element.baconjs.Observable.prototype.filter">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>filter
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (f) {
  assertObservableIsProperty(f);

  for (var _len10 = arguments.length, args = Array(_len10 &gt; 1 ? _len10 - 1 : 0), _key10 = 1; _key10 &lt; _len10; _key10++) {
    args[_key10 - 1] = arguments[_key10];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "filter", [f]), this.withHandler(function (event) {
      if (event.filter(f)) {
        return this.push(event);
      } else {
        return Bacon.more;
      }
    }));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

&lt;a name="observable-filter"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">filter</span>(f)`](#observable-filter "observable.filter(@ : Observable[A],
f : A -&gt; Bool) : Observable[A]") filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
property extractor string (like ".isValuable") instead. Just like with
[`map`](#observable-map), indeed.

&lt;a name="observable-filter-property"&gt;&lt;/a&gt;
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the
 value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true
`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.first" id="apidoc.element.baconjs.Observable.prototype.first">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return withDesc(new Bacon.Desc(this, "first", []), this.take(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.takeWhile(f)`](#observable-takewhile "observable.takeWhile(@ : Observable[A], f : A -&gt; Bool) : Observable
[A]") takes while given predicate function holds true, and then ends.
[Function Construction rules](#function-construction-rules) apply.

&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
[`observable.takeWhile(property)`](#observable-takewhile-property "observable.takeWhile(property)") takes values while
 the value of a property holds true, and then ends.

&lt;a name="observable-first"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">first</span>()`](#observable-first "observable.first(@ : Observable[A]) :
Observable[A]") takes the first element from the stream. Essentially `observable.take(1)`.

&lt;a name="observable-last"&gt;&lt;/a&gt;
[`observable.last()`](#observable-last "observable.last(@ : Observable[A]) : Observable[A]") takes the last element from
 the stream. None, if stream is empty.

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

&lt;a name="observable-skip"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.firstToPromise" id="apidoc.element.baconjs.Observable.prototype.firstToPromise">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>firstToPromise
        <span class="apidocSignatureSpan">(PromiseCtr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstToPromise = function (PromiseCtr) {
  var _this12 = this;

  if (typeof PromiseCtr !== "function") {
    if (typeof Promise === "function") {
      PromiseCtr = Promise;
    } else {
      throw new Exception("There isn't default Promise, use shim or parameter");
    }
  }

  return new PromiseCtr(function (resolve, reject) {
    return _this12.subscribe(function (event) {
      if (event.hasValue()) {
        resolve(event.value());
      }
      if (event.isError()) {
        reject(event.error);
      }

      return Bacon.noMore;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-topromise"&gt;&lt;/a&gt;
[`observable.toPromise([PromiseCtr])`](#observable-topromise "observable.toPromise(@ : Observable[A] [, PromiseCtr]) : Promise
[A]") returns a Promise which will be resolved with the last event coming from an Observable.
The global ES6 promise implementation will be used unless a promise constructor is given.
Use a shim if you need to support legacy browsers or platforms.
[caniuse promises](http://caniuse.com/#feat=promises).

&lt;a name="observable-firsttopromise"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">firstToPromise</span>([PromiseCtr])`](#observable-firsttopromise "observable
.firstToPromise(@ : Observable[A] [, PromiseCtr]) : Promise[A]") returns a Promise which will be resolved with the first event
 coming from an Observable.
Like [`toPromise`](#observable-topromise), the global ES6 promise implementation will be used unless a promise
constructor is given.

&lt;a name="observable-toesobservable"&gt;&lt;/a&gt;
[`observable.toESObservable()`](#observable-toesobservable "observable.toESObservable() : ESObservable[A]") Aliased as
 `observable[Symbol.observable]()`. Returns an
[ES Observable](https://github.com/zenparsing/es-observable) containing the
events from Bacon observable. This allows Bacon observables to be used with
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMap" id="apidoc.element.baconjs.Observable.prototype.flatMap">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMap = function () {
  return flatMap_(this, makeSpawner(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is executed for each error, before dispatching to subscribers.
That is, same as [`doAction`](#observable-doaction) but for errors.

&lt;a name="observable-not"&gt;&lt;/a&gt;
[`observable.not()`](#observable-not "observable.not(@ : Obserable[A]) : Observable[Bool]") returns a stream/property
that inverts boolean values

&lt;a name="observable-flatmap"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMap</span>(f)`](#observable-flatmap "observable.flatMap(@ : Observable
[A], f : A -&gt; Observable[B] | Event[B] | B) : EventStream[B]") for each element in the source stream, spawn a new
stream using the function `f`. Collect events from each of the spawned
streams into the result [`EventStream`](#eventstream). Note that instead of a function, you can provide a
stream/property too. Also, the return value of function `f` can be either an
`Observable` (stream/property) or a constant value. The result of
[`flatMap`](#observable-flatmap) is always an [`EventStream`](#eventstream).

The [Function Construction rules](#function-construction-rules) below apply here.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMapConcat" id="apidoc.element.baconjs.Observable.prototype.flatMapConcat">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapConcat = function () {
  var desc = new Bacon.Desc(this, "flatMapConcat", Array.prototype.slice.call(arguments, 0));
  return withDesc(desc, this.flatMapWithConcurrencyLimit.apply(this, [1].concat(_slice.call(arguments))));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.flatMapWithConcurrencyLimit(limit, f)`](#observable-flatmapwithconcurrencylimit "observable.flatMapWithConcurrencyLimit
(@ : Observable[A], limit : Number, f : A -&gt; Observable[B] | Event[B] | B) : EventStream[B]") a super method of *flatMap
* family. It limits the number of open spawned streams and buffers incoming events.
[`flatMapConcat`](#observable-flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
and [`flatMap`](#observable-flatmap) is `flatMapWithConcurrencyLimit âˆž` (all inputs are piped to output).

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmapconcat"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMapConcat</span>(f)`](#observable-flatmapconcat "observable.flatMapConcat
(@ : Observable[A], f : A -&gt; Observable[B] | Event[B] | B) : EventStream[B]") a [`flatMapWithConcurrencyLimit`](#observable
-flatmapwithconcurrencylimit) with limit of 1.

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-scan"&gt;&lt;/a&gt;
[`observable.scan(seed, f)`](#observable-scan "observable.scan(seed, f) : Property[A]") scans stream/property with given
 seed value and
accumulator function, resulting to a Property. For example, you might
use zero as seed and a "plus" function as the accumulator to create
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMapError" id="apidoc.element.baconjs.Observable.prototype.flatMapError">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapError
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapError = function (fn) {
  var desc = new Bacon.Desc(this, "flatMapError", [fn]);
  return withDesc(desc, this.mapError(function (err) {
    return new Error(err);
  }).flatMap(function (x) {
    if (x instanceof Error) {
      return fn(x.error);
    } else {
      return Bacon.once(x);
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-flatmapfirst"&gt;&lt;/a&gt;
[`observable.flatMapFirst(f)`](#observable-flatmapfirst "observable.flatMapFirst(f)") like [`flatMap`](#observable-flatmap
), but only spawns a new
stream if the previously spawned stream has ended.

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmaperror"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMapError</span>(f)`](#observable-flatmaperror "observable.flatMapError
(f)") like [`flatMap`](#observable-flatmap), but is applied only on [`Error`](#bacon-error) events. Returned values go into
 the
value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
passed through, which can be implemented using flatMapError.

&lt;a name="observable-flatmapwithconcurrencylimit"&gt;&lt;/a&gt;
[`observable.flatMapWithConcurrencyLimit(limit, f)`](#observable-flatmapwithconcurrencylimit "observable.flatMapWithConcurrencyLimit
(@ : Observable[A], limit : Number, f : A -&gt; Observable[B] | Event[B] | B) : EventStream[B]") a super method of *flatMap
* family. It limits the number of open spawned streams and buffers incoming events.
[`flatMapConcat`](#observable-flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
and [`flatMap`](#observable-flatmap) is `flatMapWithConcurrencyLimit âˆž` (all inputs are piped to output).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMapFirst" id="apidoc.element.baconjs.Observable.prototype.flatMapFirst">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapFirst
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapFirst = function () {
  return flatMap_(this, makeSpawner(arguments), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
all spawned streams, only includes them from the latest spawned stream.
You can think this as switching from stream to stream.
Note that instead of a function, you can provide a stream/property too.

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmapfirst"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMapFirst</span>(f)`](#observable-flatmapfirst "observable.flatMapFirst
(f)") like [`flatMap`](#observable-flatmap), but only spawns a new
stream if the previously spawned stream has ended.

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmaperror"&gt;&lt;/a&gt;
[`observable.flatMapError(f)`](#observable-flatmaperror "observable.flatMapError(f)") like [`flatMap`](#observable-flatmap
), but is applied only on [`Error`](#bacon-error) events. Returned values go into the
value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMapLatest" id="apidoc.element.baconjs.Observable.prototype.flatMapLatest">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapLatest = function () {
  var f = makeSpawner(arguments);
  var stream = this.toEventStream();
  return withDesc(new Bacon.Desc(this, "flatMapLatest", [f]), stream.flatMap(function (value) {
    return makeObservable(f(value)).takeUntil(stream);
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
stream.flatMap(function(text) {
    return (text != "") ? parseInt(text) : Bacon.never()
})
```

&lt;a name="observable-flatmaplatest"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMapLatest</span>(f)`](#observable-flatmaplatest "observable.flatMapLatest
(f)") like [`flatMap`](#observable-flatmap), but instead of including events from
all spawned streams, only includes them from the latest spawned stream.
You can think this as switching from stream to stream.
Note that instead of a function, you can provide a stream/property too.

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmapfirst"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.flatMapWithConcurrencyLimit" id="apidoc.element.baconjs.Observable.prototype.flatMapWithConcurrencyLimit">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>flatMapWithConcurrencyLimit
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMapWithConcurrencyLimit = function (limit) {
  for (var _len11 = arguments.length, args = Array(_len11 &gt; 1 ? _len11 - 1 : 0), _key11 = 1; _key11 &lt; _len11; _key11++) {
    args[_key11 - 1] = arguments[_key11];
  }

  var desc = new Bacon.Desc(this, "flatMapWithConcurrencyLimit", [limit].concat(args));
  return withDesc(desc, flatMap_(this, makeSpawner(args), false, limit));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-flatmaperror"&gt;&lt;/a&gt;
[`observable.flatMapError(f)`](#observable-flatmaperror "observable.flatMapError(f)") like [`flatMap`](#observable-flatmap
), but is applied only on [`Error`](#bacon-error) events. Returned values go into the
value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
passed through, which can be implemented using flatMapError.

&lt;a name="observable-flatmapwithconcurrencylimit"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMapWithConcurrencyLimit</span>(limit, f)`](#observable-flatmapwithconcurrencylimit
 "observable.flatMapWithConcurrencyLimit(@ : Observable[A], limit : Number, f : A -&gt; Observable[B] | Event[B] | B) : EventStream
[B]") a super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.
[`flatMapConcat`](#observable-flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
and [`flatMap`](#observable-flatmap) is `flatMapWithConcurrencyLimit âˆž` (all inputs are piped to output).

The [Function Construction rules](#function-construction-rules) below apply here.

&lt;a name="observable-flatmapconcat"&gt;&lt;/a&gt;
[`observable.flatMapConcat(f)`](#observable-flatmapconcat "observable.flatMapConcat(@ : Observable[A], f : A -&gt; Observable
[B] | Event[B] | B) : EventStream[B]") a [`flatMapWithConcurrencyLimit`](#observable-flatmapwithconcurrencylimit) with limit
 of 1.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.fold" id="apidoc.element.baconjs.Observable.prototype.fold">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>fold
        <span class="apidocSignatureSpan">(seed, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (seed, f) {
  return withDesc(new Bacon.Desc(this, "fold", [seed, f]), this.scan(seed, f).sampledBy(this.filter(false).mapEnd().toProperty()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
initial value when scan is applied. If there's no initial value, this works
identically to EventStream.scan: the `seed` will be the initial value of
`r`. However, if `r` already has a current/initial value `x`, the
seed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,
because there can only be 1 initial value for a Property at a time.

&lt;a name="observable-fold"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">fold</span>(seed, f)`](#observable-fold "observable.fold(seed, f) : Property
[A]") is like [`scan`](#observable-scan) but only emits the final
value, i.e. the value just before the observable ends. Returns a
[`Property`](#property).

&lt;a name="observable-reduce"&gt;&lt;/a&gt;
[`observable.reduce(seed, f)`](#observable-reduce "observable.reduce(seed,f)") synonym for [`fold`](#observable-fold).

&lt;a name="observable-diff"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.forEach" id="apidoc.element.baconjs.Observable.prototype.forEach">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>forEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function () {
  var f = makeFunctionArgs(arguments);
  return this.subscribe(function (event) {
    if (event.hasValue()) {
      return f(event.value());
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var fs = require("fs");
var shell = require('shelljs');

var testModules = fs.readdirSync("spec/specs")
    .map(function(name) { return name.substring(0, name.length - 7)})

testModules.<span class="apidocCodeKeywordSpan">forEach</span>(function(moduleName) {
  var result = shell.exec("./runtests " + moduleName)
  if (result.code != 0)
    process.exit(result.code)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.groupBy" id="apidoc.element.baconjs.Observable.prototype.groupBy">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>groupBy
        <span class="apidocSignatureSpan">(keyF)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (keyF) {
  var limitF = arguments.length &lt;= 1 || arguments[1] === undefined ? Bacon._.id : arguments[1];

  var streams = {};
  var src = this;
  return src.filter(function (x) {
    return !streams[keyF(x)];
  }).map(function (x) {
    var key = keyF(x);
    var similar = src.filter(function (x) {
      return keyF(x) === key;
    });
    var data = Bacon.once(x).concat(similar);
    var limited = limitF(data, x).withHandler(function (event) {
      this.push(event);
      if (event.isEnd()) {
        return delete streams[key];
      }
    });
    streams[key] = limited;
    return limited;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
console.log(obs.toString())
--&gt; Bacon.once(1).map(function)
obs.withDescription(src, "times", -1)
console.log(obs.toString())
--&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">groupBy</span>(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ :
Observable[A], keyF[, limitF]) : Observable[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF
` can be provided to limit grouped
stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream
and the original event causing the stream to start as parameters.

Calculator for grouped consecutive values until group is cancelled:

var events = [
  {id: 1, type: "add", val: 3 },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.inspect" id="apidoc.element.baconjs.Observable.prototype.inspect">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  if (this._name) {
    return this._name;
  } else {
    return this.desc.toString();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.internalDeps" id="apidoc.element.baconjs.Observable.prototype.internalDeps">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>internalDeps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">internalDeps = function () {
  return this.initialDesc.deps();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.last" id="apidoc.element.baconjs.Observable.prototype.last">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  var lastEvent;

  return withDesc(new Bacon.Desc(this, "last", []), this.withHandler(function (event) {
    if (event.isEnd()) {
      if (lastEvent) {
        this.push(lastEvent);
      }
      this.push(endEvent());
      return Bacon.noMore;
    } else {
      lastEvent = event;
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
[`observable.takeWhile(property)`](#observable-takewhile-property "observable.takeWhile(property)") takes values while
 the value of a property holds true, and then ends.

&lt;a name="observable-first"&gt;&lt;/a&gt;
[`observable.first()`](#observable-first "observable.first(@ : Observable[A]) : Observable[A]") takes the first element
 from the stream. Essentially `observable.take(1)`.

&lt;a name="observable-last"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">last</span>()`](#observable-last "observable.last(@ : Observable[A]) : Observable
[A]") takes the last element from the stream. None, if stream is empty.

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

&lt;a name="observable-skip"&gt;&lt;/a&gt;
[`observable.skip(n)`](#observable-skip "observable.skip(n)") skips the first n elements from the stream

&lt;a name="observable-delay"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.log" id="apidoc.element.baconjs.Observable.prototype.log">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  for (var _len18 = arguments.length, args = Array(_len18), _key18 = 0; _key18 &lt; _len18; _key18++) {
    args[_key18] = arguments[_key18];
  }

  this.subscribe(function (event) {
    if (typeof console !== "undefined" &amp;&amp; typeof console.log === "function") {
      console.log.apply(console, args.concat([event.log()]));
    }
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
passed to the function. These arguments can be simple variables, Bacon
EventStreams or Properties. For example the following will output "Bacon rules":

```js
bacon = Bacon.constant('bacon')
Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').<span class="apidocCodeKeywordSpan">log</span>();
```

&lt;a name="bacon-fromcallback-object"&gt;&lt;/a&gt;
[`Bacon.fromCallback(object, methodName [, args...])`](#bacon-fromcallback-object "Bacon.fromCallback(object, methodName [,
args...]) : EventStream[A]") a variant of fromCallback which calls the named method of a given object.

&lt;a name="bacon-fromnodecallback"&gt;&lt;/a&gt;
[`Bacon.fromNodeCallback(f [, args...])`](#bacon-fromnodecallback "Bacon.fromNodeCallback(f : (E -&gt; A -&gt; void) -&amp;#
x3e; void [, args...]) : EventStream[A]") behaves the same way as [`Bacon.fromCallback`](#bacon-fromcallback),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.map" id="apidoc.element.baconjs.Observable.prototype.map">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>map
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (p) {
  if (p &amp;&amp; p._isProperty) {
    return p.sampledBy(this, former);
  } else {
    for (var _len17 = arguments.length, args = Array(_len17 &gt; 1 ? _len17 - 1 : 0), _key17 = 1; _key17 &lt; _len17; _key17++) {
      args[_key17 - 1] = arguments[_key17];
    }

    return convertArgsToFunction(this, p, args, function (f) {
      return withDesc(new Bacon.Desc(this, "map", [f]), this.withHandler(function (event) {
        return this.push(event.fmap(f));
      }));
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

But you can do neater stuff too. The Bacon of bacon.js is in that you can transform,
filter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),
[`filter`](#observable-filter), for example, are similar to same functions in functional list programming
(like [Underscore](http://underscorejs.org/)). So, if you say

```js
var plus = $("#plus").asEventStream("click").<span class="apidocCodeKeywordSpan">map</span>(1)
var minus = $("#minus").asEventStream("click").map(-1)
var both = plus.merge(minus)
```

.. you'll have a stream that will output the number 1 when the "plus" button is clicked
and another stream outputting -1 when the "minus" button is clicked. The `both` stream will
be a merged stream containing events from both the plus and minus streams. This allows
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.mapEnd" id="apidoc.element.baconjs.Observable.prototype.mapEnd">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>mapEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapEnd = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "mapEnd", [f]), this.withHandler(function (event) {
    if (event.isEnd()) {
      this.push(nextEvent(f(event)));
      this.push(endEvent());
      return Bacon.noMore;
    } else {
      return this.push(event);
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`observable.errors()`](#observable-errors "observable.errors(@ : Observable[A]) : Observable[A]") returns a stream containing
 [`Error`](#bacon-error) events only.
Same as filtering with a function that always returns false.

&lt;a name="observable-skiperrors"&gt;&lt;/a&gt;
[`observable.skipErrors()`](#observable-skiperrors "observable.skipErrors(@ : Observable[A]) : Observable[A]") skips all
 errors.

&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">mapEnd</span>(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A],
f : -&gt; Observable[A]) : Observable[A]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

&lt;a name="observable-filter"&gt;&lt;/a&gt;
[`observable.filter(f)`](#observable-filter "observable.filter(@ : Observable[A], f : A -&gt; Bool) : Observable[A]")
filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.mapError" id="apidoc.element.baconjs.Observable.prototype.mapError">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>mapError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapError = function () {
  var f = makeFunctionArgs(arguments);
  return withDesc(new Bacon.Desc(this, "mapError", [f]), this.withHandler(function (event) {
    if (event.isError()) {
      return this.push(nextEvent(f(event.error)));
    } else {
      return this.push(event);
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The [`map`](#observable-map) method, among many others, uses [lazy evaluation](#lazy-evaluation).

&lt;a name="stream-map"&gt;&lt;/a&gt;
[`stream.map(property)`](#stream-map "stream.map(property)") maps the stream events to the current value of
the given property. This is equivalent to [`property.sampledBy(stream)`](#property-sampledby).

&lt;a name="observable-maperror"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">mapError</span>(f)`](#observable-maperror "observable.mapError(@ : Observable
[A], f : E -&gt; A) : Observable[A]") maps errors using given function. More
specifically, feeds the "error" field of the error event to the function
and produces a [`Next`](#bacon-next) event based on the return value.
The [Function Construction rules](#function-construction-rules) below apply here.
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.

&lt;a name="observable-errors"&gt;&lt;/a&gt;
[`observable.errors()`](#observable-errors "observable.errors(@ : Observable[A]) : Observable[A]") returns a stream containing
 [`Error`](#bacon-error) events only.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.name" id="apidoc.element.baconjs.Observable.prototype.name">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>name
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">name = function (name) {
  this._name = name;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Note that it's important to return the value from `this.push` so that
the connection to the underlying stream will be closed when no more
events are needed.

&lt;a name="observable-name"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">name</span>(newName)`](#observable-name "observable.name(@ : Observable[A],
newName : String) : Observable[A]") sets the name of the observable. Overrides the default
implementation of [`toString`](#observable-tostring) and `inspect`.
Returns itself.

&lt;a name="observable-withdescription"&gt;&lt;/a&gt;
[`observable.withDescription(param...)`](#observable-withdescription "observable.withDescription(@ : Observable[A], param...) :
Observable[A]") Sets the structured description of the observable. The [`toString`](#observable-tostring) and `inspect` methods
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.not" id="apidoc.element.baconjs.Observable.prototype.not">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  return withDesc(new Bacon.Desc(this, "not", []), this.map(function (x) {
    return !x;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-doerror"&gt;&lt;/a&gt;
[`observable.doError(f)`](#observable-doerror "observable.doError(f)") returns a stream/property where the function f
is executed for each error, before dispatching to subscribers.
That is, same as [`doAction`](#observable-doaction) but for errors.

&lt;a name="observable-not"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">not</span>()`](#observable-not "observable.not(@ : Obserable[A]) : Observable
[Bool]") returns a stream/property that inverts boolean values

&lt;a name="observable-flatmap"&gt;&lt;/a&gt;
[`observable.flatMap(f)`](#observable-flatmap "observable.flatMap(@ : Observable[A], f : A -&gt; Observable[B] | Event[B] |
B) : EventStream[B]") for each element in the source stream, spawn a new
stream using the function `f`. Collect events from each of the spawned
streams into the result [`EventStream`](#eventstream). Note that instead of a function, you can provide a
stream/property too. Also, the return value of function `f` can be either an
`Observable` (stream/property) or a constant value. The result of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.onEnd" id="apidoc.element.baconjs.Observable.prototype.onEnd">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEnd = function () {
  var f = makeFunctionArgs(arguments);
  return this.subscribe(function (event) {
    if (event.isEnd()) {
      return f();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
array) as function arguments to `f`.

&lt;a name="observable-onerror"&gt;&lt;/a&gt;
[`observable.onError(f)`](#observable-onerror "observable.onError(@ : Observable[A], f : Error -&gt; void) : Unsubscriber
") subscribes a callback to error events. The function will be called for each error in the stream.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-onend"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">onEnd</span>(f)`](#observable-onend "observable.onEnd(f : -&gt; void) :
Unsubscriber") subscribes a callback to stream end. The function will be called when the stream ends.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-topromise"&gt;&lt;/a&gt;
[`observable.toPromise([PromiseCtr])`](#observable-topromise "observable.toPromise(@ : Observable[A] [, PromiseCtr]) : Promise
[A]") returns a Promise which will be resolved with the last event coming from an Observable.
The global ES6 promise implementation will be used unless a promise constructor is given.
Use a shim if you need to support legacy browsers or platforms.
[caniuse promises](http://caniuse.com/#feat=promises).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.onError" id="apidoc.element.baconjs.Observable.prototype.onError">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function () {
  var f = makeFunctionArgs(arguments);
  return this.subscribe(function (event) {
    if (event.isError()) {
      return f(event.error);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
except that it expects the callback to be called in the Node.js convention:
`callback(error, data)`, where error is null if everything is fine. For example:

```js
var Bacon = require('baconjs').Bacon,
    fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
read.<span class="apidocCodeKeywordSpan">onError</span>(function(error) { console.log("Reading failed: " + error); });
read.onValue(function(value) { console.log("Read contents: " + value); });
```

&lt;a name="bacon-fromesobservable"&gt;&lt;/a&gt;
[`Bacon.fromESObservable(observable)`](#bacon-fromesobservable "Bacon.fromESObservable(observable : ESObservable[A]) : EventStream
[A]") creates an EventStream from an
[ES Observable](https://github.com/tc39/proposal-observable). Input can be any
ES Observable implementation including RxJS and Kefir.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.onValue" id="apidoc.element.baconjs.Observable.prototype.onValue">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onValue = function () {
  var f = makeFunctionArgs(arguments);
  return this.subscribe(function (event) {
    if (event.hasValue()) {
      return f(event.value());
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Each EventStream represents a stream of events. It is an Observable object, meaning
that you can listen to events in the stream using, for instance, the [`onValue`](#stream-onvalue) method
with a callback. Like this:

```js
clicks.<span class="apidocCodeKeywordSpan">onValue</span>(function() { alert("you clicked the h1 element") })
```

But you can do neater stuff too. The Bacon of bacon.js is in that you can transform,
filter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),
[`filter`](#observable-filter), for example, are similar to same functions in functional list programming
(like [Underscore](http://underscorejs.org/)). So, if you say
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.onValues" id="apidoc.element.baconjs.Observable.prototype.onValues">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>onValues
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onValues = function (f) {
  return this.onValue(function (args) {
    return f.apply(undefined, args);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
received, instead of [`Event`](#event) objects.
The [Function Construction rules](#function-construction-rules) below apply here.
Just like `subscribe`, this method returns a function for unsubscribing.
`stream.onValue` and `property.onValue` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

&lt;a name="observable-onvalues"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">onValues</span>(f)`](#observable-onvalues "observable.onValues(f)") like
 [`onValue`](#stream-onvalue), but splits the value (assuming its an
array) as function arguments to `f`.

&lt;a name="observable-onerror"&gt;&lt;/a&gt;
[`observable.onError(f)`](#observable-onerror "observable.onError(@ : Observable[A], f : Error -&gt; void) : Unsubscriber
") subscribes a callback to error events. The function will be called for each error in the stream.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-onend"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.reduce" id="apidoc.element.baconjs.Observable.prototype.reduce">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>reduce
        <span class="apidocSignatureSpan">(seed, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (seed, f) {
  return withDesc(new Bacon.Desc(this, "fold", [seed, f]), this.scan(seed, f).sampledBy(this.filter(false).mapEnd().toProperty()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-fold"&gt;&lt;/a&gt;
[`observable.fold(seed, f)`](#observable-fold "observable.fold(seed, f) : Property[A]") is like [`scan`](#observable-scan
) but only emits the final
value, i.e. the value just before the observable ends. Returns a
[`Property`](#property).

&lt;a name="observable-reduce"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">reduce</span>(seed, f)`](#observable-reduce "observable.reduce(seed,f)"
;) synonym for [`fold`](#observable-fold).

&lt;a name="observable-diff"&gt;&lt;/a&gt;
[`observable.diff(start, f)`](#observable-diff "observable.diff(start, f)") returns a Property that represents the result
 of a comparison
between the previous and current value of the Observable. For the initial value of the Observable,
the previous value will be the given start.

Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.scan" id="apidoc.element.baconjs.Observable.prototype.scan">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>scan
        <span class="apidocSignatureSpan">(seed, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (seed, f) {
  var _this10 = this;

  var resultProperty;
  f = toCombinator(f);
  var acc = toOption(seed);
  var initHandled = false;
  var subscribe = function (sink) {
    var initSent = false;
    var unsub = nop;
    var reply = Bacon.more;
    var sendInit = function () {
      if (!initSent) {
        return acc.forEach(function (value) {
          initSent = initHandled = true;
          reply = sink(new Initial(function () {
            return value;
          }));
          if (reply === Bacon.noMore) {
            unsub();
            unsub = nop;
            return unsub;
          }
        });
      }
    };
    unsub = _this10.dispatcher.subscribe(function (event) {
      if (event.hasValue()) {
        if (initHandled &amp;&amp; event.isInitial()) {
          return Bacon.more;
        } else {
            if (!event.isInitial()) {
              sendInit();
            }
            initSent = initHandled = true;
            var prev = acc.getOrElse(undefined);
            var next = f(prev, event.value());

            acc = new Some(next);
            return sink(event.apply(function () {
              return next;
            }));
          }
      } else {
        if (event.isEnd()) {
          reply = sendInit();
        }
        if (reply !== Bacon.noMore) {
          return sink(event);
        }
      }
    });
    UpdateBarrier.whenDoneWith(resultProperty, sendInit);
    return unsub;
  };
  resultProperty = new Property(new Bacon.Desc(this, "scan", [seed, f]), subscribe);
  return resultProperty;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
EventStream, but has a "current value". So things that change and have a current state are
Properties, while things that consist of discrete events are EventStreams. You could think
mouse clicks as an EventStream and mouse position as a Property. You can create Properties from
an EventStream with [`scan`](#observable-scan) or [`toProperty`](#stream-toproperty) methods. So, let's say

```js
function add(x, y) { return x + y }
var counter = both.<span class="apidocCodeKeywordSpan">scan</span>(0, add)
counter.onValue(function(sum) { $("#sum").text(sum) })
```

The `counter` property will contain the sum of the values in the `both` stream, so it's practically
a counter that can be increased and decreased using the plus and minus buttons. The [`scan`](#observable-scan) method
was used here to calculate the "current sum" of events in the `both` stream, by giving a "seed value"
`0` and an "accumulator function" `add`. The scan method creates a property that starts with the given
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.skip" id="apidoc.element.baconjs.Observable.prototype.skip">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skip
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (count) {
  return withDesc(new Bacon.Desc(this, "skip", [count]), this.withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else if (count &gt; 0) {
      count--;
      return Bacon.more;
    } else {
      return this.push(event);
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-last"&gt;&lt;/a&gt;
[`observable.last()`](#observable-last "observable.last(@ : Observable[A]) : Observable[A]") takes the last element from
 the stream. None, if stream is empty.

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

&lt;a name="observable-skip"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">skip</span>(n)`](#observable-skip "observable.skip(n)") skips the first
 n elements from the stream

&lt;a name="observable-delay"&gt;&lt;/a&gt;
[`observable.delay(delay)`](#observable-delay "observable.delay(delay)") delays the stream/property by given amount of
 milliseconds. Does not delay the initial value of a [`Property`](#property).

```js
var delayed = source.delay(2)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.skipDuplicates" id="apidoc.element.baconjs.Observable.prototype.skipDuplicates">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skipDuplicates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipDuplicates = function () {
  var isEqual = arguments.length &lt;= 0 || arguments[0] === undefined ? equals : arguments[0];

  var desc = new Bacon.Desc(this, "skipDuplicates", []);
  return withDesc(desc, this.withStateMachine(None, function (prev, event) {
    if (!event.hasValue()) {
      return [prev, [event]];
    } else if (event.isInitial() || isNone(prev) || !isEqual(prev.get(), event.value())) {
      return [new Some(event.value()), [event]];
    } else {
      return [prev, []];
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-filter-property"&gt;&lt;/a&gt;
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the
 value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true
`
at the time of the event.

&lt;a name="observable-skipduplicates"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">skipDuplicates</span>(isEqual)`](#observable-skipduplicates "observable.skipDuplicates
([isEqual])") drops consecutive equal elements. So,
from `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality
checking by default. If the isEqual argument is supplied, checks by calling
isEqual(oldValue, newValue). For instance, to do a deep comparison,you can
use the isEqual function from [underscore.js](http://underscorejs.org/)
like `stream.skipDuplicates(_.isEqual)`.

&lt;a name="observable-take"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.skipErrors" id="apidoc.element.baconjs.Observable.prototype.skipErrors">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>skipErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipErrors = function () {
  return withDesc(new Bacon.Desc(this, "skipErrors", []), this.withHandler(function (event) {
    if (event.isError()) {
      return Bacon.more;
    } else {
      return this.push(event);
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.

&lt;a name="observable-errors"&gt;&lt;/a&gt;
[`observable.errors()`](#observable-errors "observable.errors(@ : Observable[A]) : Observable[A]") returns a stream containing
 [`Error`](#bacon-error) events only.
Same as filtering with a function that always returns false.

&lt;a name="observable-skiperrors"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">skipErrors</span>()`](#observable-skiperrors "observable.skipErrors(@ : Observable
[A]) : Observable[A]") skips all errors.

&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.slidingWindow" id="apidoc.element.baconjs.Observable.prototype.slidingWindow">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>slidingWindow
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slidingWindow = function (n) {
  var minValues = arguments.length &lt;= 1 || arguments[1] === undefined ? 0 : arguments[1];

  return withDesc(new Bacon.Desc(this, "slidingWindow", [n, minValues]), this.scan([], function (window, value) {
    return window.concat([value]).slice(-n);
  }).filter(function (values) {
    return values.length &gt;= minValues;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# produces values 4, 6
```

See also [`zipWith`](#bacon-zipwith) and [`zipAsArray`](#bacon-zipasarray) for zipping more than 2 sources.

&lt;a name="observable-slidingwindow"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">slidingWindow</span>(max [, min])`](#observable-slidingwindow "observable.
slidingWindow(max[, min])") returns a Property that represents a
"sliding window" into the history of the values of the Observable. The
result Property will have a value that is an array containing the last `n`
values of the original observable, where `n` is at most the value of the
`max` argument, and at least the value of the `min` argument. If the
`min` argument is omitted, there's no lower limit of values.

For example, if you have a stream `s` with value a sequence 1 - 2 - 3 - 4 - 5, the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.subscribe" id="apidoc.element.baconjs.Observable.prototype.subscribe">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (sink) {
  return UpdateBarrier.wrappedSubscribe(this, sink);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
---------------------------------------------

Both EventStream and Property share the Observable interface, and hence share a lot of methods.
Methods typically return observables so that methods can be chained; exceptions are noted.
Common methods are listed below.

&lt;a name="observable-subscribe"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">subscribe</span>(f)`](#observable-subscribe "observable.subscribe(f)")
subscribes given handler function to event stream. Function will receive Event objects (see below).
The subscribe() call returns a `unsubscribe` function that you can call to unsubscribe.
You can also unsubscribe by returning [`Bacon.noMore`](#bacon-nomore) from the handler function as a reply
to an Event.
`stream.subscribe` and `property.subscribe` behave similarly, except that the latter also
pushes the initial value of the property, in case there is one.

&lt;a name="observable-onvalue"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.subscribeInternal" id="apidoc.element.baconjs.Observable.prototype.subscribeInternal">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>subscribeInternal
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeInternal = function (sink) {
  return this.dispatcher.subscribe(sink);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.take" id="apidoc.element.baconjs.Observable.prototype.take">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>take
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">take = function (count) {
  if (count &lt;= 0) {
    return Bacon.never();
  }
  return withDesc(new Bacon.Desc(this, "take", [count]), this.withHandler(function (event) {
    if (!event.hasValue()) {
      return this.push(event);
    } else {
      count--;
      if (count &gt; 0) {
        return this.push(event);
      } else {
        if (count === 0) {
          this.push(event);
        }
        this.push(endEvent());
        return Bacon.noMore;
      }
    }
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
from `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality
checking by default. If the isEqual argument is supplied, checks by calling
isEqual(oldValue, newValue). For instance, to do a deep comparison,you can
use the isEqual function from [underscore.js](http://underscorejs.org/)
like `stream.skipDuplicates(_.isEqual)`.

&lt;a name="observable-take"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">take</span>(n)`](#observable-take "observable.take(@ : Observable[A], n :
Number) : Observable[A]") takes at most n values from the stream and then ends the stream. If the stream has
fewer than n values then it is unaffected.
Equal to [`Bacon.never()`](#bacon-never) if `n &lt;= 0`.

&lt;a name="observable-takeuntil"&gt;&lt;/a&gt;
[`observable.takeUntil(stream)`](#observable-takeuntil "observable.takeUntil(@ : Observable[A], stream : EventStream[B]) :
Observable[A]") takes elements from source until a Next event appears in the other stream.
If other stream ends without value, it is ignored.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.takeWhile" id="apidoc.element.baconjs.Observable.prototype.takeWhile">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>takeWhile
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeWhile = function (f) {
  assertObservableIsProperty(f);

  for (var _len20 = arguments.length, args = Array(_len20 &gt; 1 ? _len20 - 1 : 0), _key20 = 1; _key20 &lt; _len20; _key20++) {
    args[_key20 - 1] = arguments[_key20];
  }

  return convertArgsToFunction(this, f, args, function (f) {
    return withDesc(new Bacon.Desc(this, "takeWhile", [f]), this.withHandler(function (event) {
      if (event.filter(f)) {
        return this.push(event);
      } else {
        this.push(endEvent());
        return Bacon.noMore;
      }
    }));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Equal to [`Bacon.never()`](#bacon-never) if `n &lt;= 0`.

&lt;a name="observable-takeuntil"&gt;&lt;/a&gt;
[`observable.takeUntil(stream)`](#observable-takeuntil "observable.takeUntil(@ : Observable[A], stream : EventStream[B]) :
Observable[A]") takes elements from source until a Next event appears in the other stream.
If other stream ends without value, it is ignored.

&lt;a name="observable-takewhile"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">takeWhile</span>(f)`](#observable-takewhile "observable.takeWhile(@ : Observable
[A], f : A -&gt; Bool) : Observable[A]") takes while given predicate function holds true, and then ends.
[Function Construction rules](#function-construction-rules) apply.

&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
[`observable.takeWhile(property)`](#observable-takewhile-property "observable.takeWhile(property)") takes values while
 the value of a property holds true, and then ends.

&lt;a name="observable-first"&gt;&lt;/a&gt;
[`observable.first()`](#observable-first "observable.first(@ : Observable[A]) : Observable[A]") takes the first element
 from the stream. Essentially `observable.take(1)`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.throttle" id="apidoc.element.baconjs.Observable.prototype.throttle">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>throttle
        <span class="apidocSignatureSpan">(delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throttle = function (delay) {
  return this.delayChanges(new Bacon.Desc(this, "throttle", [delay]), function (changes) {
    return changes.bufferWithTime(delay).map(function (values) {
      return values[values.length - 1];
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:    asdf----asdf----
delayed:   --asdf----asdf--
```

&lt;a name="observable-throttle"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">throttle</span>(delay)`](#observable-throttle "observable.throttle(delay)&amp;#
x22;) throttles stream/property by given amount
of milliseconds. Events are emitted with the minimum interval of
[`delay`](#observable-delay). The implementation is based on [`stream.bufferWithTime`](#stream-bufferwithtime).
Does not affect emitting the initial value of a [`Property`](#property).

Example:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.toESObservable" id="apidoc.element.baconjs.Observable.prototype.toESObservable">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toESObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toESObservable = function () {
  return new ESObservable(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-firsttopromise"&gt;&lt;/a&gt;
[`observable.firstToPromise([PromiseCtr])`](#observable-firsttopromise "observable.firstToPromise(@ : Observable[A] [, PromiseCtr
]) : Promise[A]") returns a Promise which will be resolved with the first event coming from an Observable.
Like [`toPromise`](#observable-topromise), the global ES6 promise implementation will be used unless a promise
constructor is given.

&lt;a name="observable-toesobservable"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">toESObservable</span>()`](#observable-toesobservable "observable.toESObservable
() : ESObservable[A]") Aliased as `observable[Symbol.observable]()`. Returns an
[ES Observable](https://github.com/zenparsing/es-observable) containing the
events from Bacon observable. This allows Bacon observables to be used with
`Observable.from` and provides interoperability with other ES observable
implementations such as RxJS and Kefir.

&lt;a name="observable-map"&gt;&lt;/a&gt;
[`observable.map(f)`](#observable-map "observable.map(@ : Observable[A], f : A -&gt; B) : Observable[B]") maps values
 using given function, returning a new
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.toPromise" id="apidoc.element.baconjs.Observable.prototype.toPromise">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toPromise
        <span class="apidocSignatureSpan">(PromiseCtr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPromise = function (PromiseCtr) {
  return this.last().firstToPromise(PromiseCtr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-onend"&gt;&lt;/a&gt;
[`observable.onEnd(f)`](#observable-onend "observable.onEnd(f : -&gt; void) : Unsubscriber") subscribes a callback to
 stream end. The function will be called when the stream ends.
Just like `subscribe`, this method returns a function for unsubscribing.

&lt;a name="observable-topromise"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">toPromise</span>([PromiseCtr])`](#observable-topromise "observable.toPromise
(@ : Observable[A] [, PromiseCtr]) : Promise[A]") returns a Promise which will be resolved with the last event coming from
an Observable.
The global ES6 promise implementation will be used unless a promise constructor is given.
Use a shim if you need to support legacy browsers or platforms.
[caniuse promises](http://caniuse.com/#feat=promises).

&lt;a name="observable-firsttopromise"&gt;&lt;/a&gt;
[`observable.firstToPromise([PromiseCtr])`](#observable-firsttopromise "observable.firstToPromise(@ : Observable[A] [, PromiseCtr
]) : Promise[A]") returns a Promise which will be resolved with the first event coming from an Observable.
Like [`toPromise`](#observable-topromise), the global ES6 promise implementation will be used unless a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.toString" id="apidoc.element.baconjs.Observable.prototype.toString">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  if (this._name) {
    return this._name;
  } else {
    return this.desc.toString();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.withDescription" id="apidoc.element.baconjs.Observable.prototype.withDescription">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>withDescription
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withDescription = function () {
  this.desc = describe.apply(undefined, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-name"&gt;&lt;/a&gt;
[`observable.name(newName)`](#observable-name "observable.name(@ : Observable[A], newName : String) : Observable[A]")
sets the name of the observable. Overrides the default
implementation of [`toString`](#observable-tostring) and `inspect`.
Returns itself.

&lt;a name="observable-withdescription"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">withDescription</span>(param...)`](#observable-withdescription "observable
.withDescription(@ : Observable[A], param...) : Observable[A]") Sets the structured description of the observable. The [`toString
`](#observable-tostring) and `inspect` methods
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

var src = Bacon.once(1)
var obs = src.map(function(x) { return -x })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.withStateMachine" id="apidoc.element.baconjs.Observable.prototype.withStateMachine">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>withStateMachine
        <span class="apidocSignatureSpan">(initState, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStateMachine = function (initState, f) {
  var state = initState;
  var desc = new Bacon.Desc(this, "withStateMachine", [initState, f]);
  return withDesc(desc, this.withHandler(function (event) {
    var fromF = f(state, event);
    var newState = fromF[0];
    var outputs = fromF[1];

    state = newState;
    var reply = Bacon.more;
    for (var i = 0, output; i &lt; outputs.length; i++) {
      output = outputs[i];
      reply = this.push(output);
      if (reply === Bacon.noMore) {
        return reply;
      }
    }
    return reply;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-combine"&gt;&lt;/a&gt;
[`observable.combine(property2, f)`](#observable-combine "observable.combine(property2, f)") combines the latest values
 of the two
streams or properties using a two-arg function. Similarly to [`scan`](#observable-scan), you can use a
method name instead, so you could do `a.combine(b, ".concat")` for two
properties with array value. The result is a Property.

&lt;a name="observable-withstatemachine"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">withStateMachine</span>(initState, f)`](#observable-withstatemachine "observable
.withStateMachine(initState, f)") lets you run a state machine
on an observable. Give it an initial state object and a state
transformation function that processes each incoming event and
returns an array containing the next state and an array of output
events. Here's an example where we calculate the total sum of all
numbers in the stream and output the value on stream end:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Observable.prototype.zip" id="apidoc.element.baconjs.Observable.prototype.zip">
        function <span class="apidocSignatureSpan">baconjs.Observable.prototype.</span>zip
        <span class="apidocSignatureSpan">(other, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function (other, f) {
  return withDesc(new Bacon.Desc(this, "zip", [other]), Bacon.zipWith([this, other], f || Array));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This would result to following elements in the result stream:

    1 - 0 = 1
    2 - 1 = 1
    3 - 2 = 1

&lt;a name="observable-zip"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">zip</span>(other [, f])`](#observable-zip "observable.zip(other [, f])"
;) return an EventStream with elements
pair-wise lined up with events from this and the other EventStream or Property.
A zipped stream will publish only when it has a value from each
source and will only produce values up to when any single source ends.

The given function `f` is used to create the result value from value in the two
sources. If no function is given, the values are zipped into an array.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Property" id="apidoc.module.baconjs.Property">module baconjs.Property</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.Property.Property" id="apidoc.element.baconjs.Property.Property">
        function <span class="apidocSignatureSpan">baconjs.</span>Property
        <span class="apidocSignatureSpan">(desc, subscribe, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Property(desc, subscribe, handler) {
  Observable.call(this, desc);
  assertFunction(subscribe);
  this.dispatcher = new PropertyDispatcher(this, subscribe, handler);
  registerObs(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.Property.prototype" id="apidoc.module.baconjs.Property.prototype">module baconjs.Property.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.and" id="apidoc.element.baconjs.Property.prototype.and">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function (other) {
  return withDesc(new Bacon.Desc(this, "and", [other]), this.combine(other, function (x, y) {
    return x &amp;&amp; y;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="property-changes"&gt;&lt;/a&gt;
[`property.changes()`](#property-changes "property.changes()") returns an [`EventStream`](#eventstream) of property value
 changes.
Returns exactly the same events as the property itself, except any Initial
events. Note that [`property.changes()`](#property-changes) does NOT skip duplicate values, use .skipDuplicates() for that.

&lt;a name="property-and"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">and</span>(other)`](#property-and "property.and(other)") combines properties
 with the `&amp;&amp;` operator.

&lt;a name="property-or"&gt;&lt;/a&gt;
[`property.or(other)`](#property-or "property.or(other)") combines properties with the `||` operator.

&lt;a name="property-startwith"&gt;&lt;/a&gt;
[`property.startWith(value)`](#property-startwith "property.startWith(value)") adds an initial "default" value
 for the
Property. If the Property doesn't have an initial value of it's own, the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.bufferingThrottle" id="apidoc.element.baconjs.Property.prototype.bufferingThrottle">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>bufferingThrottle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferingThrottle = function () {
  return Bacon.Observable.prototype.bufferingThrottle.apply(this, arguments).toProperty();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```
source:                      asdf----asdf----
source.debounceImmediate(2): a-d-----a-d-----
```

&lt;a name="observable-bufferingthrottle"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">bufferingThrottle</span>(minimumInterval)`](#observable-bufferingthrottle "
;observable.bufferingThrottle(@ : Observable[A], minimumInterval) : EventStream[A]") throttles the observable using a buffer
 so that at most one value event in minimumInteval is issued.
Unlike [`throttle`](#observable-throttle), it doesn't discard the excessive events but buffers them instead, outputting
them with a rate of at most one value per minimumInterval.

Example:

```js
var throttled = source.bufferingThrottle(2)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.changes" id="apidoc.element.baconjs.Property.prototype.changes">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function () {
  var _this4 = this;

  return new EventStream(new Bacon.Desc(this, "changes", []), function (sink) {
    return _this4.dispatcher.subscribe(function (event) {
      if (!event.isInitial()) {
        return sink(event);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="property-sampledby-f"&gt;&lt;/a&gt;
[`property.sampledBy(streamOrProperty, f)`](#property-sampledby-f "property.sampledBy(streamOrProperty, f)") samples the
 property on stream
events. The result values will be formed using the given function
`f(propertyValue, samplerValue)`. You can use a method name (such as
".concat") instead of a function too.

&lt;a name="property-changes"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">changes</span>()`](#property-changes "property.changes()") returns an [`
EventStream`](#eventstream) of property value changes.
Returns exactly the same events as the property itself, except any Initial
events. Note that [`property.changes()`](#property-changes) does NOT skip duplicate values, use .skipDuplicates() for that.

&lt;a name="property-and"&gt;&lt;/a&gt;
[`property.and(other)`](#property-and "property.and(other)") combines properties with the `&amp;&amp;` operator.

&lt;a name="property-or"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.delayChanges" id="apidoc.element.baconjs.Property.prototype.delayChanges">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>delayChanges
        <span class="apidocSignatureSpan">(desc, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayChanges = function (desc, f) {
  return withDesc(desc, addPropertyInitValueToStream(this, f(this.changes())));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.or" id="apidoc.element.baconjs.Property.prototype.or">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function (other) {
  return withDesc(new Bacon.Desc(this, "or", [other]), this.combine(other, function (x, y) {
    return x || y;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Returns exactly the same events as the property itself, except any Initial
events. Note that [`property.changes()`](#property-changes) does NOT skip duplicate values, use .skipDuplicates() for that.

&lt;a name="property-and"&gt;&lt;/a&gt;
[`property.and(other)`](#property-and "property.and(other)") combines properties with the `&amp;&amp;` operator.

&lt;a name="property-or"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">or</span>(other)`](#property-or "property.or(other)") combines properties
 with the `||` operator.

&lt;a name="property-startwith"&gt;&lt;/a&gt;
[`property.startWith(value)`](#property-startwith "property.startWith(value)") adds an initial "default" value
 for the
Property. If the Property doesn't have an initial value of it's own, the
given value will be used as the initial value. If the property has an
initial value of its own, the given value will be ignored.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.sample" id="apidoc.element.baconjs.Property.prototype.sample">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>sample
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sample = function (interval) {
  return withDesc(new Bacon.Desc(this, "sample", [interval]), this.sampledBy(Bacon.interval(interval, {})));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
myProperty.assign($("#my-button"), "toggle")
```

Note that the [`assign`](#property-assign) method is actually just a synonym for [`onValue`](#property-onvalue) and
the [function construction rules](#function-construction-rules) below apply to both.

&lt;a name="property-sample"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">sample</span>(interval)`](#property-sample "property.sample(interval)")
creates an EventStream by sampling the
property value at given interval (in milliseconds)

&lt;a name="property-sampledby"&gt;&lt;/a&gt;
[`property.sampledBy(stream)`](#property-sampledby "property.sampledBy(stream)") creates an EventStream by sampling the
property value at each event from the given stream. The result
EventStream will contain the property value at each event in the source
stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.sampledBy" id="apidoc.element.baconjs.Property.prototype.sampledBy">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>sampledBy
        <span class="apidocSignatureSpan">(sampler, combinator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampledBy = function (sampler, combinator) {
  var lazy = false;
  if (typeof combinator !== "undefined" &amp;&amp; combinator !== null) {
    combinator = toCombinator(combinator);
  } else {
    lazy = true;
    combinator = function (f) {
      return f.value();
    };
  }
  var thisSource = new Source(this, false, lazy);
  var samplerSource = new Source(sampler, true, lazy);
  var stream = Bacon.when([thisSource, samplerSource], combinator);
  var result = sampler._isProperty ? stream.toProperty() : stream;
  return withDesc(new Bacon.Desc(this, "sampledBy", [sampler, combinator]), result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the input values. If keyCode was a function, the result stream would
contain the values returned by the function.
The [Function Construction rules](#function-construction-rules) below apply here.
The [`map`](#observable-map) method, among many others, uses [lazy evaluation](#lazy-evaluation).

&lt;a name="stream-map"&gt;&lt;/a&gt;
[`stream.map(property)`](#stream-map "stream.map(property)") maps the stream events to the current value of
the given property. This is equivalent to [`property.<span class="apidocCodeKeywordSpan">sampledBy</span>(stream)`](#property-sampledby
).

&lt;a name="observable-maperror"&gt;&lt;/a&gt;
[`observable.mapError(f)`](#observable-maperror "observable.mapError(@ : Observable[A], f : E -&gt; A) : Observable[A]"
;) maps errors using given function. More
specifically, feeds the "error" field of the error event to the function
and produces a [`Next`](#bacon-next) event based on the return value.
The [Function Construction rules](#function-construction-rules) below apply here.
You can omit the argument to produce a [`Next`](#bacon-next) event with `undefined` value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.startWith" id="apidoc.element.baconjs.Property.prototype.startWith">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>startWith
        <span class="apidocSignatureSpan">(seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startWith = function (seed) {
  return withDesc(new Bacon.Desc(this, "startWith", [seed]), this.scan(seed, function (prev, next) {
    return next;
  }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[`stream.merge(otherStream)`](#stream-merge "stream.merge(otherStream)") merges two streams into one stream that delivers
 events from both

&lt;a name="stream-holdwhen"&gt;&lt;/a&gt;
[`stream.holdWhen(valve)`](#stream-holdwhen "stream.holdWhen(@ : EventStream[A], valve : Observable[B]) : EventStream[A]"
;) pauses and buffers the event stream if last event in valve is truthy.
All buffered events are released when valve becomes falsy.

&lt;a name="stream-startwith"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">startWith</span>(value)`](#stream-startwith "stream.startWith(value)") adds
 a starting value to the stream, i.e. concats a
single-element stream contains [`value`](#event-value) with this stream.

&lt;a name="stream-skipwhile"&gt;&lt;/a&gt;
[`stream.skipWhile(f)`](#stream-skipwhile "stream.skipWhile(f)") skips elements until the given predicate function returns
 falsy once, and then
lets all events pass through.
The [Function Construction rules](#function-construction-rules) below apply here.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.takeUntil" id="apidoc.element.baconjs.Property.prototype.takeUntil">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>takeUntil
        <span class="apidocSignatureSpan">(stopper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeUntil = function (stopper) {
  var changes = this.changes().takeUntil(stopper);
  return withDesc(new Bacon.Desc(this, "takeUntil", [stopper]), addPropertyInitValueToStream(this, changes));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="observable-take"&gt;&lt;/a&gt;
[`observable.take(n)`](#observable-take "observable.take(@ : Observable[A], n : Number) : Observable[A]") takes at most
 n values from the stream and then ends the stream. If the stream has
fewer than n values then it is unaffected.
Equal to [`Bacon.never()`](#bacon-never) if `n &lt;= 0`.

&lt;a name="observable-takeuntil"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">takeUntil</span>(stream)`](#observable-takeuntil "observable.takeUntil(@ :
Observable[A], stream : EventStream[B]) : Observable[A]") takes elements from source until a Next event appears in the other
 stream.
If other stream ends without value, it is ignored.

&lt;a name="observable-takewhile"&gt;&lt;/a&gt;
[`observable.takeWhile(f)`](#observable-takewhile "observable.takeWhile(@ : Observable[A], f : A -&gt; Bool) : Observable
[A]") takes while given predicate function holds true, and then ends.
[Function Construction rules](#function-construction-rules) apply.

&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.toEventStream" id="apidoc.element.baconjs.Property.prototype.toEventStream">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>toEventStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEventStream = function () {
  var _this5 = this;

  return new EventStream(new Bacon.Desc(this, "toEventStream", []), function (sink) {
    return _this5.dispatcher.subscribe(function (event) {
      if (event.isInitial()) {
        event = event.toNext();
      }
      return sink(event);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="new-bacon-eventstream"&gt;&lt;/a&gt;
[`new Bacon.EventStream(subscribe)`](#new-bacon-eventstream "new Bacon.EventStream(subscribe)") creates an [`EventStream
`](#eventstream) with the given subscribe function.

[`property.changes`](#property-changes) creates a stream of changes to the [`Property`](#property). The stream *does not* include
an event for the current value of the Property at the time this method was called.

&lt;a name="property-toeventstream"&gt;&lt;/a&gt;
[`property.<span class="apidocCodeKeywordSpan">toEventStream</span>()`](#property-toeventstream "property.toEventStream(@ :
Property[A]) : EventStream[A]") creates an EventStream based on this Property. The stream contains also an event for the current
value of this Property at the time this method was called.

[`new Bacon.Bus()`](#new-bacon-bus) creates a pushable/pluggable stream (see [Bus](#bus) section below)

Pro tip: you can also put Errors into streams created with the
constructors above, by using an [`Bacon.Error`](#bacon-error) object instead of a plain
value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.toProperty" id="apidoc.element.baconjs.Property.prototype.toProperty">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>toProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toProperty = function () {
  assertNoArguments(arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;a name="stream-bufferwithtimeorcount"&gt;&lt;/a&gt;
[`stream.bufferWithTimeOrCount(delay, count)`](#stream-bufferwithtimeorcount "stream.bufferWithTimeOrCount(delay, count)"
;) buffers stream events and
flushes when either the buffer contains the given number elements or the
given amount of milliseconds has passed since last buffered event.

&lt;a name="stream-toproperty"&gt;&lt;/a&gt;
[`stream.<span class="apidocCodeKeywordSpan">toProperty</span>()`](#stream-toproperty "stream.toProperty(@ : EventStream[A]) :
Property[A]") creates a Property based on the
EventStream. Without arguments, you'll get a Property without an initial value.
The Property will get its first actual value from the stream, and after that it'll
always have a current value.

&lt;a name="stream-toproperty-initialValue"&gt;&lt;/a&gt;
[`stream.toProperty(initialValue)`](#stream-toproperty-initialValue "stream.toProperty(initialValue)") creates a Property
 based on the
EventStream with the given initial value that will be used as the current value until
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.Property.prototype.withHandler" id="apidoc.element.baconjs.Property.prototype.withHandler">
        function <span class="apidocSignatureSpan">baconjs.Property.prototype.</span>withHandler
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withHandler = function (handler) {
  return new Property(new Bacon.Desc(this, "withHandler", [handler]), this.dispatcher.subscribe, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-endonerror-f"&gt;&lt;/a&gt;
[`observable.endOnError(f)`](#observable-endonerror-f "observable.endOnError(f)") ends the `Observable` on first [`Error
`](#bacon-error) event for which
the given predicate function returns true. The error is included in the
output of the returned `Observable`. The [Function Construction rules](#function-construction-rules) apply, so
you can do for example `.endOnError(".serious")`.

&lt;a name="observable-withhandler"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">withHandler</span>(f)`](#observable-withhandler "observable.withHandler(f)&amp;#
x22;) lets you do more custom event handling: you
get all events to your function and you can output any number of events
and end the stream if you choose. For example, to send an error and end
the stream in case a value is below zero:

```js
if (event.hasValue() &amp;&amp; event.value() &lt; 0) {
this.push(new Bacon.Error("Value below zero"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.UpdateBarrier" id="apidoc.module.baconjs.UpdateBarrier">module baconjs.UpdateBarrier</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.afterTransaction" id="apidoc.element.baconjs.UpdateBarrier.afterTransaction">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>afterTransaction
        <span class="apidocSignatureSpan">(obs, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterTransaction = function (obs, f) {
  if (rootEvent || aftersStack.length) {
    ensureStackHeight(1);
    var stackIndexForThisObs = 0;
    while (stackIndexForThisObs &lt; aftersStackHeight - 1) {
      if (containsObs(obs, aftersStack[stackIndexForThisObs][0])) {
        break;
      }
      stackIndexForThisObs++;
    }
    var listFromStack = aftersStack[stackIndexForThisObs][0];
    listFromStack.push([obs, f]);
    if (!rootEvent) {
      processAfters();
    }
  } else {
      return f();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.currentEventId" id="apidoc.element.baconjs.UpdateBarrier.currentEventId">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>currentEventId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentEventId = function () {
  return rootEvent ? rootEvent.id : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.hasWaiters" id="apidoc.element.baconjs.UpdateBarrier.hasWaiters">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>hasWaiters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasWaiters = function () {
  return waiterObs.length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.inTransaction" id="apidoc.element.baconjs.UpdateBarrier.inTransaction">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>inTransaction
        <span class="apidocSignatureSpan">(event, context, f, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inTransaction = function (event, context, f, args) {
  if (rootEvent) {
    return f.apply(context, args);
  } else {
    rootEvent = event;
    try {
      var result = f.apply(context, args);

      flush();
    } finally {
      rootEvent = undefined;
      processAfters();
    }
    return result;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.whenDoneWith" id="apidoc.element.baconjs.UpdateBarrier.whenDoneWith">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>whenDoneWith
        <span class="apidocSignatureSpan">(obs, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whenDoneWith = function (obs, f) {
  if (rootEvent) {
    var obsWaiters = waiters[obs.id];
    if (!(typeof obsWaiters !== "undefined" &amp;&amp; obsWaiters !== null)) {
      obsWaiters = waiters[obs.id] = [f];
      return waiterObs.push(obs);
    } else {
      return obsWaiters.push(f);
    }
  } else {
    return f();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.UpdateBarrier.wrappedSubscribe" id="apidoc.element.baconjs.UpdateBarrier.wrappedSubscribe">
        function <span class="apidocSignatureSpan">baconjs.UpdateBarrier.</span>wrappedSubscribe
        <span class="apidocSignatureSpan">(obs, sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrappedSubscribe = function (obs, sink) {
  var unsubd = false;
  var shouldUnsub = false;
  var doUnsub = function () {
    shouldUnsub = true;
    return shouldUnsub;
  };
  var unsub = function () {
    unsubd = true;
    return doUnsub();
  };
  doUnsub = obs.dispatcher.subscribe(function (event) {
    return afterTransaction(obs, function () {
      if (!unsubd) {
        var reply = sink(event);
        if (reply === Bacon.noMore) {
          return unsub();
        }
      }
    });
  });
  if (shouldUnsub) {
    doUnsub();
  }
  return unsub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs._" id="apidoc.module.baconjs._">module baconjs._</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs._.all" id="apidoc.element.baconjs._.all">
        function <span class="apidocSignatureSpan">baconjs._.</span>all
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (xs) {
  var f = arguments.length &lt;= 1 || arguments[1] === undefined ? _.id : arguments[1];

  for (var i = 0, x; i &lt; xs.length; i++) {
    x = xs[i];
    if (!f(x)) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.always" id="apidoc.element.baconjs._.always">
        function <span class="apidocSignatureSpan">baconjs._.</span>always
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">always = function (x) {
  return function () {
    return x;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.any" id="apidoc.element.baconjs._.any">
        function <span class="apidocSignatureSpan">baconjs._.</span>any
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (xs) {
  var f = arguments.length &lt;= 1 || arguments[1] === undefined ? _.id : arguments[1];

  for (var i = 0, x; i &lt; xs.length; i++) {
    x = xs[i];
    if (f(x)) {
      return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.bind" id="apidoc.element.baconjs._.bind">
        function <span class="apidocSignatureSpan">baconjs._.</span>bind
        <span class="apidocSignatureSpan">(fn, me)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (fn, me) {
  return function () {
    return fn.apply(me, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.cached" id="apidoc.element.baconjs._.cached">
        function <span class="apidocSignatureSpan">baconjs._.</span>cached
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cached = function (f) {
  var value = None;
  return function () {
    if (typeof value !== "undefined" &amp;&amp; value !== null ? value._isNone : undefined) {
      value = f();
      f = undefined;
    }
    return value;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.contains" id="apidoc.element.baconjs._.contains">
        function <span class="apidocSignatureSpan">baconjs._.</span>contains
        <span class="apidocSignatureSpan">(xs, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (xs, x) {
  return _.indexOf(xs, x) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.each" id="apidoc.element.baconjs._.each">
        function <span class="apidocSignatureSpan">baconjs._.</span>each
        <span class="apidocSignatureSpan">(xs, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (xs, f) {
  for (var key in xs) {
    if (Object.prototype.hasOwnProperty.call(xs, key)) {
      var value = xs[key];
      f(key, value);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.empty" id="apidoc.element.baconjs._.empty">
        function <span class="apidocSignatureSpan">baconjs._.</span>empty
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (xs) {
  return xs.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.filter" id="apidoc.element.baconjs._.filter">
        function <span class="apidocSignatureSpan">baconjs._.</span>filter
        <span class="apidocSignatureSpan">(f, xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (f, xs) {
  var filtered = [];
  for (var i = 0, x; i &lt; xs.length; i++) {
    x = xs[i];
    if (f(x)) {
      filtered.push(x);
    }
  }
  return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-mapend"&gt;&lt;/a&gt;
[`observable.mapEnd(f)`](#observable-mapend "observable.mapEnd(@ : Observable[A], f : -&gt; Observable[A]) : Observable[A
]") Adds an extra [`Next`](#bacon-next) event just before End. The value is created
by calling the given function when the source stream ends. Instead of a
function, a static value can be used. You can omit the argument to
produce a Next event with `undefined` value.

&lt;a name="observable-filter"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">filter</span>(f)`](#observable-filter "observable.filter(@ : Observable[A],
f : A -&gt; Bool) : Observable[A]") filters values using given predicate function.
Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all) or a
property extractor string (like ".isValuable") instead. Just like with
[`map`](#observable-map), indeed.

&lt;a name="observable-filter-property"&gt;&lt;/a&gt;
[`observable.filter(property)`](#observable-filter-property "observable.filter(property)") filters values based on the
 value of a
property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true
`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.flatMap" id="apidoc.element.baconjs._.flatMap">
        function <span class="apidocSignatureSpan">baconjs._.</span>flatMap
        <span class="apidocSignatureSpan">(f, xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMap = function (f, xs) {
  return _.fold(xs, [], function (ys, x) {
    return ys.concat(f(x));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
is executed for each error, before dispatching to subscribers.
That is, same as [`doAction`](#observable-doaction) but for errors.

&lt;a name="observable-not"&gt;&lt;/a&gt;
[`observable.not()`](#observable-not "observable.not(@ : Obserable[A]) : Observable[Bool]") returns a stream/property
that inverts boolean values

&lt;a name="observable-flatmap"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">flatMap</span>(f)`](#observable-flatmap "observable.flatMap(@ : Observable
[A], f : A -&gt; Observable[B] | Event[B] | B) : EventStream[B]") for each element in the source stream, spawn a new
stream using the function `f`. Collect events from each of the spawned
streams into the result [`EventStream`](#eventstream). Note that instead of a function, you can provide a
stream/property too. Also, the return value of function `f` can be either an
`Observable` (stream/property) or a constant value. The result of
[`flatMap`](#observable-flatmap) is always an [`EventStream`](#eventstream).

The [Function Construction rules](#function-construction-rules) below apply here.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.fold" id="apidoc.element.baconjs._.fold">
        function <span class="apidocSignatureSpan">baconjs._.</span>fold
        <span class="apidocSignatureSpan">(xs, seed, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (xs, seed, f) {
  for (var i = 0, x; i &lt; xs.length; i++) {
    x = xs[i];
    seed = f(seed, x);
  }
  return seed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
initial value when scan is applied. If there's no initial value, this works
identically to EventStream.scan: the `seed` will be the initial value of
`r`. However, if `r` already has a current/initial value `x`, the
seed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,
because there can only be 1 initial value for a Property at a time.

&lt;a name="observable-fold"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">fold</span>(seed, f)`](#observable-fold "observable.fold(seed, f) : Property
[A]") is like [`scan`](#observable-scan) but only emits the final
value, i.e. the value just before the observable ends. Returns a
[`Property`](#property).

&lt;a name="observable-reduce"&gt;&lt;/a&gt;
[`observable.reduce(seed, f)`](#observable-reduce "observable.reduce(seed,f)") synonym for [`fold`](#observable-fold).

&lt;a name="observable-diff"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.head" id="apidoc.element.baconjs._.head">
        function <span class="apidocSignatureSpan">baconjs._.</span>head
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (xs) {
  return xs[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.id" id="apidoc.element.baconjs._.id">
        function <span class="apidocSignatureSpan">baconjs._.</span>id
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function (x) {
  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.indexOf" id="apidoc.element.baconjs._.indexOf">
        function <span class="apidocSignatureSpan">baconjs._.</span>indexOf
        <span class="apidocSignatureSpan">(xs, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (xs, x) {
  return xs.indexOf(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.indexWhere" id="apidoc.element.baconjs._.indexWhere">
        function <span class="apidocSignatureSpan">baconjs._.</span>indexWhere
        <span class="apidocSignatureSpan">(xs, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexWhere = function (xs, f) {
  for (var i = 0, y; i &lt; xs.length; i++) {
    y = xs[i];
    if (f(y)) {
      return i;
    }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.isFunction" id="apidoc.element.baconjs._.isFunction">
        function <span class="apidocSignatureSpan">baconjs._.</span>isFunction
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFunction = function (f) {
  return typeof f === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.last" id="apidoc.element.baconjs._.last">
        function <span class="apidocSignatureSpan">baconjs._.</span>last
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function (xs) {
  return xs[xs.length - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="observable-takewhile-property"&gt;&lt;/a&gt;
[`observable.takeWhile(property)`](#observable-takewhile-property "observable.takeWhile(property)") takes values while
 the value of a property holds true, and then ends.

&lt;a name="observable-first"&gt;&lt;/a&gt;
[`observable.first()`](#observable-first "observable.first(@ : Observable[A]) : Observable[A]") takes the first element
 from the stream. Essentially `observable.take(1)`.

&lt;a name="observable-last"&gt;&lt;/a&gt;
[`observable.<span class="apidocCodeKeywordSpan">last</span>()`](#observable-last "observable.last(@ : Observable[A]) : Observable
[A]") takes the last element from the stream. None, if stream is empty.

*Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.

&lt;a name="observable-skip"&gt;&lt;/a&gt;
[`observable.skip(n)`](#observable-skip "observable.skip(n)") skips the first n elements from the stream

&lt;a name="observable-delay"&gt;&lt;/a&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.map" id="apidoc.element.baconjs._.map">
        function <span class="apidocSignatureSpan">baconjs._.</span>map
        <span class="apidocSignatureSpan">(f, xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (f, xs) {
  return (function () {
    var result = [];
    for (var i = 0, x; i &lt; xs.length; i++) {
      x = xs[i];
      result.push(f(x));
    }
    return result;
  })();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

But you can do neater stuff too. The Bacon of bacon.js is in that you can transform,
filter and combine these streams in a multitude of ways (see API below). The methods [`map`](#observable-map),
[`filter`](#observable-filter), for example, are similar to same functions in functional list programming
(like [Underscore](http://underscorejs.org/)). So, if you say

```js
var plus = $("#plus").asEventStream("click").<span class="apidocCodeKeywordSpan">map</span>(1)
var minus = $("#minus").asEventStream("click").map(-1)
var both = plus.merge(minus)
```

.. you'll have a stream that will output the number 1 when the "plus" button is clicked
and another stream outputting -1 when the "minus" button is clicked. The `both` stream will
be a merged stream containing events from both the plus and minus streams. This allows
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.negate" id="apidoc.element.baconjs._.negate">
        function <span class="apidocSignatureSpan">baconjs._.</span>negate
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negate = function (f) {
  return function (x) {
    return !f(x);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.remove" id="apidoc.element.baconjs._.remove">
        function <span class="apidocSignatureSpan">baconjs._.</span>remove
        <span class="apidocSignatureSpan">(x, xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (x, xs) {
  var i = _.indexOf(xs, x);
  if (i &gt;= 0) {
    return xs.splice(i, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.tail" id="apidoc.element.baconjs._.tail">
        function <span class="apidocSignatureSpan">baconjs._.</span>tail
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function (xs) {
  return xs.slice(1, xs.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.toArray" id="apidoc.element.baconjs._.toArray">
        function <span class="apidocSignatureSpan">baconjs._.</span>toArray
        <span class="apidocSignatureSpan">(xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (xs) {
  return isArray(xs) ? xs : [xs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.toString" id="apidoc.element.baconjs._.toString">
        function <span class="apidocSignatureSpan">baconjs._.</span>toString
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (obj) {
  var internals, key, value;
  var hasProp = ({}).hasOwnProperty;
  try {
    recursionDepth++;
    if (obj == null) {
      return "undefined";
    } else if (_.isFunction(obj)) {
      return "function";
    } else if (isArray(obj)) {
      if (recursionDepth &gt; 5) {
        return "[..]";
      }
      return "[" + _.map(_.toString, obj).toString() + "]";
    } else if ((obj != null ? obj.toString : void 0) != null &amp;&amp; obj.toString !== Object.prototype.toString) {
      return obj.toString();
    } else if (typeof obj === "object") {
      if (recursionDepth &gt; 5) {
        return "{..}";
      }
      internals = (function () {
        var results = [];
        for (key in obj) {
          if (!hasProp.call(obj, key)) continue;
          value = (function () {
            var error;
            try {
              return obj[key];
            } catch (error) {
              return error;
            }
          })();
          results.push(_.toString(key) + ":" + _.toString(value));
        }
        return results;
      })();
      return "{" + internals + "}";
    } else {
      return obj;
    }
  } finally {
    recursionDepth--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
use this data recursively to create a string representation for the observable. This method
is probably useful for Bacon core / library / plugin development only.

For example:

    var src = Bacon.once(1)
    var obs = src.map(function(x) { return -x })
    console.log(obs.<span class="apidocCodeKeywordSpan">toString</span>())
    --&gt; Bacon.once(1).map(function)
    obs.withDescription(src, "times", -1)
    console.log(obs.toString())
    --&gt; Bacon.once(1).times(-1)

&lt;a name="observable-groupby"&gt;&lt;/a&gt;
[`observable.groupBy(keyF [, limitF])`](#observable-groupby "observable.groupBy(@ : Observable[A], keyF[, limitF]) : Observable
[Observable[A]]") Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs._.without" id="apidoc.element.baconjs._.without">
        function <span class="apidocSignatureSpan">baconjs._.</span>without
        <span class="apidocSignatureSpan">(x, xs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">without = function (x, xs) {
  return _.filter(function (y) {
    return y !== x;
  }, xs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baconjs.scheduler" id="apidoc.module.baconjs.scheduler">module baconjs.scheduler</a></h1>


    <h2>
        <a href="#apidoc.element.baconjs.scheduler.clearInterval" id="apidoc.element.baconjs.scheduler.clearInterval">
        function <span class="apidocSignatureSpan">baconjs.scheduler.</span>clearInterval
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearInterval = function (id) {
  return clearInterval(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.scheduler.clearTimeout" id="apidoc.element.baconjs.scheduler.clearTimeout">
        function <span class="apidocSignatureSpan">baconjs.scheduler.</span>clearTimeout
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimeout = function (id) {
  return clearTimeout(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.scheduler.now" id="apidoc.element.baconjs.scheduler.now">
        function <span class="apidocSignatureSpan">baconjs.scheduler.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function () {
  return new Date().getTime();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.scheduler.setInterval" id="apidoc.element.baconjs.scheduler.setInterval">
        function <span class="apidocSignatureSpan">baconjs.scheduler.</span>setInterval
        <span class="apidocSignatureSpan">(f, i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setInterval = function (f, i) {
  return setInterval(f, i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baconjs.scheduler.setTimeout" id="apidoc.element.baconjs.scheduler.setTimeout">
        function <span class="apidocSignatureSpan">baconjs.scheduler.</span>setTimeout
        <span class="apidocSignatureSpan">(f, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (f, d) {
  return setTimeout(f, d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>